use anyhow::{anyhow, Context, Result};
use bcrypt::verify;
use dialoguer::{Confirm, Input, Password, Select};
use dotenv::dotenv;
use hostname::get as get_hostname_raw;
use landlock::{
    Access, AccessFs, AccessNet, NetPort, PathBeneath, PathFd, Ruleset, RulesetAttr,
    RulesetCreatedAttr, RulesetStatus, ABI,
};
use once_cell::sync::Lazy;
use postgres::{Config, NoTls};
use r2d2::{Pool, PooledConnection};
use r2d2_postgres::PostgresConnectionManager;
use regex::Regex;
use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::{BufRead, BufReader};
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};
use std::time::Duration;
use tempfile::TempDir;

// -----------------------------------------------------------------------
// Corrected helpers (recommended changes)
// -----------------------------------------------------------------------

/// Stricter executable path validation
fn validate_executable_path(path_str: &str) -> Result<std::path::PathBuf> {
    let path = PathBuf::from(path_str);

    // Ensure the path actually exists
    if !path.exists() {
        return Err(anyhow!("Executable path does not exist: {}", path_str));
    }

    // Use symlink_metadata so we can check for symlinks
    let meta = fs::symlink_metadata(&path)
        .with_context(|| format!("Failed to read metadata for '{}'", path_str))?;

    // Reject symlinks to prevent potential path traversal
    if meta.file_type().is_symlink() {
        return Err(anyhow!("Symlinks are not allowed: {}", path_str));
    }

    if !meta.is_file() {
        return Err(anyhow!("Path is not a regular file: {}", path_str));
    }

    // On Unix, do extra permission checks
    #[cfg(unix)]
    {
        let perms = meta.permissions();
        let mode = perms.mode();

        // Ensure the file is executable by at least the owner (0o111).
        if (mode & 0o111) == 0 {
            return Err(anyhow!("File is not executable: {}", path_str));
        }

        // Additional security: reject world-writable executables
        if (mode & 0o002) != 0 {
            return Err(anyhow!("World-writable executables are not allowed: {}", path_str));
        }
    }

    // Use canonicalize for a fully qualified path
    fs::canonicalize(&path)
        .map_err(|e| anyhow!("Failed to canonicalize path '{}': {}", path_str, e))
}

/// Example log path sanitizer
fn sanitize_log_path(path: &Path) -> String {
    // For illustration, assume we have some "home" path:
    // You can replace this with any actual logic for retrieving a home dir
    let home_dir = PathBuf::from("/home/unknown"); 
    let home_str = home_dir.to_string_lossy();      // This is a Cow<str>
    let path_str = path.to_string_lossy();          // Also a Cow<str>

    // Convert the Cow<str> to &str before calling replace
    path_str.replace(home_str.as_ref(), "<HOME>")
}

/// Safely parse environment variables into a set of canonical paths
fn parse_env_paths(var_name: &str) -> HashSet<PathBuf> {
    env::var(var_name)
        .unwrap_or_default()
        .split(':')
        .filter(|s| !s.is_empty())
        .filter_map(|path_str| {
            // Try canonicalizing; skip any invalid or non-existent paths
            fs::canonicalize(path_str).ok()
        })
        .collect()
}

/// Safely parse environment variables into ports, ignoring any invalid or privileged (<1024) ports
fn parse_env_ports(var_name: &str) -> HashSet<u16> {
    env::var(var_name)
        .unwrap_or_default()
        .split(':')
        .filter_map(|s| s.parse::<u16>().ok())
        .filter(|&port| port >= 1024) // example: skip <1024 if you like
        .collect()
}

/// Create a database connection pool with environment variables
fn create_db_pool() -> Result<Pool<PostgresConnectionManager<NoTls>>> {
    let host = env::var("DB_HOST")
        .context("DB_HOST environment variable must be set")?;
    let port = env::var("DB_PORT")
        .context("DB_PORT environment variable must be set")?
        .parse::<u16>()
        .context("Invalid DB_PORT")?;
    let user = env::var("DB_USER")
        .context("DB_USER environment variable must be set")?;
    let pass = env::var("DB_PASS")
        .context("DB_PASS environment variable must be set")?;
    let dbname = env::var("DB_NAME")
        .context("DB_NAME environment variable must be set")?;

    let mut pg_config = Config::new();
    pg_config
        .host(&host)
        .port(port)
        .user(&user)
        .password(&pass)
        .dbname(&dbname)
        .connect_timeout(Duration::from_secs(10));

    let manager = PostgresConnectionManager::new(pg_config, NoTls);

    Pool::builder()
        .max_size(10)
        .min_idle(Some(5))
        .connection_timeout(Duration::from_secs(30))
        .build(manager)
        .context("Failed to create database connection pool")
}

// -----------------------------------------------------------------------
// Main Production code (updated to use create_db_pool for the static POOL)
// -----------------------------------------------------------------------

#[derive(Debug)]
struct AppPolicy {
    ro_paths: HashSet<PathBuf>,
    rw_paths: HashSet<PathBuf>,
    tcp_bind: HashSet<u16>,
    tcp_connect: HashSet<u16>,
    allowed_ips: HashSet<String>,
    allowed_domains: HashSet<String>,
}

#[derive(Debug)]
struct User {
    user_id: i32,
    #[allow(dead_code)]
    username: String,
}

// Our global static pool, created via `create_db_pool`
static POOL: Lazy<Pool<PostgresConnectionManager<NoTls>>> = Lazy::new(|| {
    dotenv().ok();
    create_db_pool().expect("Failed to create database pool")
});

pub fn get_db_conn() -> Result<PooledConnection<PostgresConnectionManager<NoTls>>> {
    POOL.get().context("Failed to get DB connection from pool")
}

// -----------------------------------------------------------------------
// RBAC Functions
// -----------------------------------------------------------------------

fn authenticate_user(username: &str, password: &str) -> Result<User> {
    let mut conn = get_db_conn().context("Failed to get DB connection for authentication")?;

    let row = conn
        .query_opt(
            "SELECT user_id, password_hash FROM users WHERE username = $1",
            &[&username],
        )
        .context("Authentication query failed")?
        .ok_or_else(|| anyhow!("User not found"))?;

    let stored_hash: String = row.get(1);
    if verify(password, &stored_hash).map_err(|e| anyhow!("Password verification failed: {}", e))? {
        Ok(User {
            user_id: row.get(0),
            username: username.to_string(),
        })
    } else {
        Err(anyhow!("Invalid credentials"))
    }
}

fn has_permission(user_id: i32, permission: &str) -> Result<bool> {
    let mut conn = get_db_conn().context("Failed to get DB connection for permission check")?;
    let count: i64 = conn
        .query_one(
            r#"
        SELECT COUNT(*) FROM role_permissions
        WHERE role_id IN (
            SELECT role_id FROM user_roles WHERE user_id = $1
        )
        AND permission_id = (
            SELECT permission_id FROM permissions WHERE permission_name = $2
        )
        "#,
            &[&user_id, &permission],
        )?
        .get(0);

    Ok(count > 0)
}

// -----------------------------------------------------------------------
// DB Functions
// -----------------------------------------------------------------------

fn parse_paths(paths: String) -> HashSet<PathBuf> {
    paths
        .split(':')
        .filter(|s| !s.is_empty())
        .map(PathBuf::from)
        .collect()
}

fn parse_ports(ports: String) -> HashSet<u16> {
    ports
        .split(':')
        .filter_map(|s| s.parse().ok())
        .collect()
}

fn parse_ips(ips: String) -> HashSet<String> {
    ips
        .split(':')
        .filter(|s| !s.is_empty())
        .map(String::from)
        .collect()
}

fn parse_domains(domains: String) -> HashSet<String> {
    domains
        .split(':')
        .filter(|s| !s.is_empty())
        .map(String::from)
        .collect()
}

impl AppPolicy {
    fn default_policy_for_role(role_id: i32) -> Result<Self> {
        let mut conn =
            get_db_conn().context("Failed to get DB connection for fetching default policy")?;

        let query = "
            SELECT default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains
            FROM default_policies
            WHERE role_id = $1
        ";

        let row = conn
            .query_one(query, &[&role_id])
            .context("Failed to fetch default policy from database")?;

        let ro_paths = parse_paths(row.get("default_ro"));
        let rw_paths = parse_paths(row.get("default_rw"));
        let tcp_bind = parse_ports(row.get("tcp_bind"));
        let tcp_connect = parse_ports(row.get("tcp_connect"));
        let allowed_ips = parse_ips(row.get("allowed_ips"));
        let allowed_domains = parse_domains(row.get("allowed_domains"));

        Ok(Self {
            ro_paths,
            rw_paths,
            tcp_bind,
            tcp_connect,
            allowed_ips,
            allowed_domains,
        })
    }

    fn join_ips(ips: &HashSet<String>) -> String {
        ips.iter().cloned().collect::<Vec<_>>().join(":")
    }

    fn join_domains(domains: &HashSet<String>) -> String {
        domains.iter().cloned().collect::<Vec<_>>().join(":")
    }

    fn join_paths(paths: &HashSet<PathBuf>) -> String {
        paths
            .iter()
            .map(|p| p.to_string_lossy().into_owned())
            .collect::<Vec<_>>()
            .join(":")
    }

    fn join_ports(ports: &HashSet<u16>) -> String {
        ports
            .iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(":")
    }

    fn contains_path(&self, path: &Path) -> bool {
        self.ro_paths.contains(path) || self.rw_paths.contains(path)
    }
}

fn fetch_policy_from_db(app: &str, user: &User) -> Result<AppPolicy> {
    let mut client = get_db_conn().context("Failed to get DB connection for policy fetch")?;

    // Get user's roles (assuming single role for simplicity)
    let roles: Vec<i32> = client
        .query(
            "SELECT r.role_id FROM roles r
         JOIN user_roles ur ON r.role_id = ur.role_id
         WHERE ur.user_id = $1",
            &[&user.user_id],
        )?
        .iter()
        .map(|row| row.get(0))
        .collect();

    // Try each role until we find a policy
    for &role_id in &roles {
        let query = r#"
            SELECT default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains
            FROM app_policy
            WHERE app_name = $1 AND role_id = $2
        "#;

        if let Some(row) = client.query_opt(query, &[&app, &role_id])? {
            let ro_paths = parse_paths(row.get("default_ro"));
            let rw_paths = parse_paths(row.get("default_rw"));
            let tcp_bind = parse_ports(row.get("tcp_bind"));
            let tcp_connect = parse_ports(row.get("tcp_connect"));
            let allowed_ips = parse_ips(row.get("allowed_ips"));
            let allowed_domains = parse_domains(row.get("allowed_domains"));

            return Ok(AppPolicy {
                ro_paths,
                rw_paths,
                tcp_bind,
                tcp_connect,
                allowed_ips,
                allowed_domains,
            });
        }
    }

    // Fallback to default policy for the first role (or handle no role differently)
    let default_role_id = roles.first().copied().unwrap_or(0);
    AppPolicy::default_policy_for_role(default_role_id)
}

fn update_policy_in_db(app: &str, policy: &AppPolicy, user: &User) -> Result<()> {
    if !has_permission(user.user_id, "manage_policies")? {
        return Err(anyhow!("Insufficient permissions to modify policies"));
    }

    let mut conn = get_db_conn().context("Failed to get DB connection for policy update")?;
    let mut tx = conn.transaction().context("Failed to start transaction")?;

    // Retrieve the user's role (assume one primary role per user)
    let role_id: i32 = tx
        .query_one(
            "SELECT r.role_id FROM roles r
         JOIN user_roles ur ON r.role_id = ur.role_id
         WHERE ur.user_id = $1 LIMIT 1",
            &[&user.user_id],
        )?
        .get(0);

    let sql = r#"
    INSERT INTO app_policy
    (app_name, role_id, default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains, updated_at)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
    ON CONFLICT (app_name, role_id) DO UPDATE SET
        default_ro = EXCLUDED.default_ro,
        default_rw = EXCLUDED.default_rw,
        tcp_bind = EXCLUDED.tcp_bind,
        tcp_connect = EXCLUDED.tcp_connect,
        allowed_ips = EXCLUDED.allowed_ips,
        allowed_domains = EXCLUDED.allowed_domains,
        updated_at = NOW()
    "#;

    tx.execute(
        sql,
        &[
            &app,
            &role_id,
            &AppPolicy::join_paths(&policy.ro_paths),
            &AppPolicy::join_paths(&policy.rw_paths),
            &AppPolicy::join_ports(&policy.tcp_bind),
            &AppPolicy::join_ports(&policy.tcp_connect),
            &AppPolicy::join_ips(&policy.allowed_ips),
            &AppPolicy::join_domains(&policy.allowed_domains),
        ],
    )
    .with_context(|| {
        format!(
            "Failed to update policy for app '{}' and role_id '{}'",
            app, role_id
        )
    })?;

    tx.commit().context("Failed to commit policy update")?;

    log_event(
        user.user_id,
        app,
        Path::new("policy"),
        "policy_update",
        "success",
    )?;

    Ok(())
}

// -----------------------------------------------------------------------
// Logging
// -----------------------------------------------------------------------

fn get_hostname() -> String {
    get_hostname_raw()
        .unwrap_or_else(|_| "unknown".into())
        .to_string_lossy()
        .into_owned()
}

fn log_event(user_id: i32, app: &str, path: &Path, operation: &str, result: &str) -> Result<()> {
    let hostname = get_hostname();

    // Use sanitized path for logging
    let denied_path = sanitize_log_path(path);

    let mut conn = get_db_conn().context("Failed to get DB connection for logging")?;
    let mut tx = conn
        .transaction()
        .context("Failed to start logging transaction")?;

    let sql = r#"
        INSERT INTO sandbox_events
        (hostname, app_name, denied_path, operation, result, user_id)
        VALUES ($1, $2, $3, $4, $5, $6)
    "#;

    tx.execute(
        sql,
        &[&hostname, &app, &denied_path, &operation, &result, &user_id],
    )
    .with_context(|| {
        format!(
            "Failed to log event: app={}, path={}, op={}",
            app, denied_path, operation
        )
    })?;

    tx.commit().context("Failed to commit log entry")?;
    Ok(())
}

// -----------------------------------------------------------------------
// Landlock Enforcement
// -----------------------------------------------------------------------

fn enforce_landlock(policy: &AppPolicy) -> Result<()> {
    let abi = ABI::V5;
    let base = Ruleset::default()
        .handle_access(AccessFs::from_all(abi))?
        .handle_access(AccessNet::BindTcp)?
        .handle_access(AccessNet::ConnectTcp)?;

    let mut created = base
        .create()
        .context("Failed to create Landlock ruleset (check if Landlock is supported)")?;

    // Add read-only paths
    for path in &policy.ro_paths {
        if let Ok(canonical_path) = fs::canonicalize(path) {
            let fd = PathFd::new(canonical_path.as_os_str()).with_context(|| {
                format!("Could not create PathFd for '{}'", canonical_path.display())
            })?;
            let rule = PathBeneath::new(fd, AccessFs::from_read(abi));
            created = created.add_rule(rule).with_context(|| {
                format!(
                    "Could not add read-only rule for '{}'",
                    canonical_path.display()
                )
            })?;
        }
    }

    // Add read-write paths
    for path in &policy.rw_paths {
        if let Ok(canonical_path) = fs::canonicalize(path) {
            let fd = PathFd::new(canonical_path.as_os_str()).with_context(|| {
                format!("Could not create PathFd for '{}'", canonical_path.display())
            })?;
            let rule = PathBeneath::new(fd, AccessFs::from_all(abi));
            created = created.add_rule(rule).with_context(|| {
                format!(
                    "Could not add read/write rule for '{}'",
                    canonical_path.display()
                )
            })?;
        }
    }

    // Add TCP rules
    for port in &policy.tcp_bind {
        created = created
            .add_rule(NetPort::new(*port, AccessNet::BindTcp))
            .with_context(|| format!("Could not add TCP bind rule for port {}", port))?;
    }
    for port in &policy.tcp_connect {
        created = created
            .add_rule(NetPort::new(*port, AccessNet::ConnectTcp))
            .with_context(|| format!("Could not add TCP connect rule for port {}", port))?;
    }

    let status = created
        .restrict_self()
        .context("Failed to restrict self with Landlock ruleset")?;
    if status.ruleset == RulesetStatus::NotEnforced {
        return Err(anyhow!("Landlock is not supported by the running kernel"));
    }

    println!("Landlock ruleset enforced successfully.");
    Ok(())
}

// -----------------------------------------------------------------------
// Running in "sandbox" mode (strace instrumentation) + denial processing
// -----------------------------------------------------------------------

fn run_sandbox_run_mode(
    app_path: &Path,
    app_args: &[String],
    policy: &AppPolicy,
    log_file_prefix: &str,
) -> Result<(ExitStatus, TempDir)> {
    let tempdir = TempDir::new().context("Failed to create temporary directory for strace logs")?;
    let log_prefix_path = tempdir.path().join(log_file_prefix);
    let log_prefix_str = log_prefix_path.to_string_lossy().to_string();

    // Prepare environment variables for the child
    // (using safer parse_env_* for examples, but we still join our sets)
    let mut child_env = env::vars().collect::<Vec<(String, String)>>();

    child_env.push(("LL_FS_RO".into(), AppPolicy::join_paths(&policy.ro_paths)));
    child_env.push(("LL_FS_RW".into(), AppPolicy::join_paths(&policy.rw_paths)));
    child_env.push(("LL_TCP_BIND".into(), AppPolicy::join_ports(&policy.tcp_bind)));
    child_env.push(("LL_TCP_CONNECT".into(), AppPolicy::join_ports(&policy.tcp_connect)));
    child_env.push(("LL_ALLOWED_IPS".into(), AppPolicy::join_ips(&policy.allowed_ips)));
    child_env.push(("LL_ALLOWED_DOMAINS".into(), AppPolicy::join_domains(&policy.allowed_domains)));

    let current_exe =
        env::current_exe().context("Failed to get current executable for strace invocation")?;

    let status = Command::new("strace")
        .args(&[
            "-ff",
            "-yy",
            "-e",
            "trace=file,process,openat,getdents,stat,connect,socket,bind",
        ])
        .arg("-o")
        .arg(&log_prefix_str)
        // We'll re-invoke our *own* binary with `--sandbox` so that `sandbox_main` is used.
        .arg(&current_exe)
        .arg("--sandbox")
        .arg(app_path)
        .args(app_args)
        .env_clear()
        .envs(child_env)
        .status()
        .with_context(|| format!("Failed to spawn strace for '{}'", app_path.display()))?;

    Ok((status, tempdir))
}

/// Parse strace output for EACCES or EPERM lines, collecting either file paths or "tcp:<port>"
fn parse_denied_lines(log_dir: &Path, prefix: &str) -> Result<HashSet<String>> {
    let path_re = Regex::new(
        r#"(?x)
        ^
        (?:
           openat\(.*?,\s*"([^"]+)" |
           (?:open|stat|execve|access|readlink)\("([^"]+)" |
           getdents(?:64)?\(.*?,\s*"([^"]+)"
        )
        "#,
    )?;

    let net_re = Regex::new(
        r#"(?x)
        ^
        (?:
           (?:connect|bind)\(.*?sin_port=htons\((\d+)\)
        )
        "#,
    )?;

    let mut denials = HashSet::new();

    let entries = fs::read_dir(log_dir)
        .with_context(|| format!("Failed to read directory '{}'", log_dir.display()))?;
    for entry_result in entries {
        let entry = entry_result
            .with_context(|| format!("Error iterating over directory '{}'", log_dir.display()))?;
        let fname = entry.file_name().to_string_lossy().to_string();
        if !fname.starts_with(prefix) {
            continue;
        }

        let file = fs::File::open(entry.path()).with_context(|| {
            format!("Failed to open strace log file '{}'", entry.path().display())
        })?;

        for line_result in BufReader::new(file).lines() {
            let line = line_result
                .with_context(|| format!("Failed to read line in '{}'", entry.path().display()))?;

            if !(line.contains("EACCES") || line.contains("EPERM")) {
                continue;
            }

            // Try matching a file-based syscall
            if let Some(caps) = path_re.captures(&line) {
                let path_str = caps
                    .get(1)
                    .or_else(|| caps.get(2))
                    .or_else(|| caps.get(3))
                    .map(|m| m.as_str())
                    .unwrap_or("");
                if !path_str.is_empty() {
                    denials.insert(path_str.to_string());
                    continue;
                }
            }

            // If not file-based, match network-based syscalls
            if let Some(caps) = net_re.captures(&line) {
                if let Some(port_match) = caps.get(1) {
                    let port = port_match.as_str();
                    denials.insert(format!("tcp:{}", port));
                    continue;
                }
            }
        }
    }

    Ok(denials)
}

fn process_denials(
    log_dir: &Path,
    prefix: &str,
    policy: &mut AppPolicy,
    app: &str,
    user: &User,
) -> Result<bool> {
    let denied_entries = parse_denied_lines(log_dir, prefix)?;

    let mut updated = false;
    let can_manage = has_permission(user.user_id, "manage_policies")?;

    for entry in denied_entries {
        if entry.starts_with("tcp:") {
            let port_str = entry.trim_start_matches("tcp:");
            if let Ok(port) = port_str.parse::<u16>() {
                if policy.tcp_bind.contains(&port) || policy.tcp_connect.contains(&port) {
                    continue;
                }
                if can_manage {
                    let choices = &["Allow TCP Bind", "Allow TCP Connect", "Deny"];
                    let selection = Select::new()
                        .with_prompt(format!(
                            "TCP connection denied for port {}. Allow as:",
                            port
                        ))
                        .items(choices)
                        .default(2)
                        .interact()?;
                    match selection {
                        0 => {
                            policy.tcp_bind.insert(port);
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "granted_tcp_bind",
                            )?;
                            updated = true;
                        }
                        1 => {
                            policy.tcp_connect.insert(port);
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "granted_tcp_connect",
                            )?;
                            updated = true;
                        }
                        _ => {
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "denied",
                            )?;
                        }
                    }
                } else {
                    log_event(
                        user.user_id,
                        app,
                        Path::new(&format!("tcp:{}", port)),
                        "syscall",
                        "denied",
                    )?;
                }
            }
        } else {
            let path = PathBuf::from(&entry);
            if policy.contains_path(&path) {
                continue;
            }
            let final_path = fs::canonicalize(&path).unwrap_or(path.clone());
            if can_manage {
                let choices = &["Read-Only", "Read-Write", "Deny"];
                let selection = Select::new()
                    .with_prompt(format!(
                        "Access denied for {}. Allow as:",
                        final_path.display()
                    ))
                    .items(choices)
                    .default(2)
                    .interact()?;
                match selection {
                    0 => {
                        policy.ro_paths.insert(final_path.clone());
                        log_event(user.user_id, app, &final_path, "syscall", "granted_ro")?;
                        updated = true;
                    }
                    1 => {
                        policy.rw_paths.insert(final_path.clone());
                        log_event(user.user_id, app, &final_path, "syscall", "granted_rw")?;
                        updated = true;
                    }
                    _ => {
                        log_event(user.user_id, app, &final_path, "syscall", "denied")?;
                    }
                }
            } else {
                log_event(user.user_id, app, &final_path, "syscall", "denied")?;
            }
        }
    }

    // Return true only if we updated AND we have permission
    Ok(updated && can_manage)
}

// -----------------------------------------------------------------------
// management_flow and sandbox_main
// -----------------------------------------------------------------------

fn management_flow() -> Result<()> {
    // Prompt for username
    let username = Input::<String>::new()
        .with_prompt("Username")
        .interact()
        .context("Failed to read username")?;

    // Prompt for password
    let password = Password::new()
        .with_prompt("Password")
        .interact()
        .context("Failed to read password")?;

    // Attempt authentication
    let user = authenticate_user(&username, &password).context("Authentication failed")?;

    // Check whether the user can execute
    if !has_permission(user.user_id, "execute_apps")? {
        return Err(anyhow!("Insufficient permissions to execute applications"));
    }

    // Parse command-line args for the target application
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        return Err(anyhow!("Usage: {} <APP> [ARGS...]", args[0]));
    }
    let raw_app = &args[1];
    let app_args = &args[2..];

    // -------------------------------------------------------------------
    // **Validate the executable path**:
    // This ensures that 'raw_app' refers to a valid, non-symlink,
    // executable file (and not world-writable, if on Unix).
    // -------------------------------------------------------------------
    let validated_path = validate_executable_path(raw_app)?;
    println!("Using validated executable path: {}", validated_path.display());

    // Fetch the policy for the specified application
    let mut policy = fetch_policy_from_db(raw_app, &user)
        .with_context(|| format!("Failed to fetch policy for '{}'", raw_app))?;

    // First run with strace
    let first_prefix = "sandboxer_first.log";
    let (first_status, first_tempdir) =
        run_sandbox_run_mode(&validated_path, app_args, &policy, first_prefix)?;

    let has_denials = !parse_denied_lines(first_tempdir.path(), first_prefix)?.is_empty();
    let needs_processing = !first_status.success() || has_denials;

    if needs_processing {
        println!("Processing denials...");
        let changed = process_denials(
            first_tempdir.path(),
            first_prefix,
            &mut policy,
            raw_app,
            &user,
        )?;

        if changed {
            update_policy_in_db(raw_app, &policy, &user)?;

            let do_second_run = Confirm::new()
                .with_prompt("Would you like to run the application again with the updated policy?")
                .default(true)
                .interact()?;

            if do_second_run {
                let second_prefix = "sandboxer_second.log";
                let (second_status, second_tempdir) =
                    run_sandbox_run_mode(&validated_path, app_args, &policy, second_prefix)?;

                let second_denials = parse_denied_lines(second_tempdir.path(), second_prefix)?;

                if second_denials.is_empty() && second_status.success() {
                    println!("Second run successful. No denied operations.");
                } else {
                    println!("Denied operations still detected. Further updates may be needed.");
                }
            } else {
                println!("Exiting without second run.");
            }
        } else {
            // No changes were made
            if has_permission(user.user_id, "manage_policies")? {
                println!("No policy changes made. Skipping second run.");
            } else {
                println!("Insufficient permissions for policy updates. Skipping second run.");
            }
        }
    } else {
        println!("Program executed successfully under sandbox.");
    }

    Ok(())
}

/// This is the entry point that actually enforces Landlock rules and then runs the specified command.
fn sandbox_main() -> ! {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 3 {
        eprintln!("Usage: {} --sandbox <APP> [ARGS...]", args[0]);
        std::process::exit(1);
    }

    let cmd = &args[2];
    let cmd_args = &args[3..];

    // Create a policy object from environment variables (instead of DB),
    // so that this child process knows what it can do.
    let policy = AppPolicy {
        ro_paths: parse_env_paths("LL_FS_RO"),
        rw_paths: parse_env_paths("LL_FS_RW"),
        tcp_bind: parse_env_ports("LL_TCP_BIND"),
        tcp_connect: parse_env_ports("LL_TCP_CONNECT"),
        allowed_ips: env::var("LL_ALLOWED_IPS")
            .unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect(),
        allowed_domains: env::var("LL_ALLOWED_DOMAINS")
            .unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect(),
    };

    // Actually enforce Landlock
    if let Err(e) = enforce_landlock(&policy) {
        eprintln!("Failed to enforce Landlock rules: {}", e);
        std::process::exit(1);
    }

    // Finally, execute the real command inside this restricted environment
    match Command::new(cmd).args(cmd_args).status() {
        Ok(status) => std::process::exit(status.code().unwrap_or(1)),
        Err(e) => {
            eprintln!("Failed to execute '{}': {}", cmd, e);
            std::process::exit(1);
        }
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() >= 2 && args[1] == "--sandbox" {
        sandbox_main();
    } else {
        if let Err(e) = management_flow() {
            eprintln!("Error in management flow: {:?}", e);
            std::process::exit(1);
        }
    }
}

// -----------------------------------------------------------------------
// In your main code, add a testing-only default_policy constructor:
// -----------------------------------------------------------------------
impl AppPolicy {
    /// A simple helper returning a hardcoded policy for tests.
    #[cfg(test)]
    fn default_policy() -> Self {
        AppPolicy {
            ro_paths: vec![PathBuf::from("/bin"), PathBuf::from("/etc")]
                .into_iter()
                .collect(),
            rw_paths: vec![PathBuf::from("/tmp")].into_iter().collect(),
            tcp_bind: HashSet::new(),
            tcp_connect: HashSet::new(),
            allowed_ips: HashSet::new(),
            allowed_domains: HashSet::new(),
        }
    }
}

// -----------------------------------------------------------------------
// Test code begins here.
// -----------------------------------------------------------------------
#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;
    use anyhow::Result; // if you're using anyhow for test returns

    /// Test a default in-memory policy. Adjust the contents as you see fit.
    #[test]
    fn test_default_policy() {
        let policy = AppPolicy::default_policy();
        assert!(policy.ro_paths.contains(Path::new("/bin")));
        assert!(policy.ro_paths.contains(Path::new("/etc")));
        assert!(policy.rw_paths.contains(Path::new("/tmp")));
    }

    #[test]
    fn test_join_paths_and_ports() {
        let mut policy = AppPolicy::default_policy();

        // Insert a read-only path, then check the joined result
        policy.ro_paths.insert(PathBuf::from("/home"));
        let ro_joined = AppPolicy::join_paths(&policy.ro_paths);
        assert!(ro_joined.contains("/home"));

        // Insert a TCP bind port, then check the joined result
        policy.tcp_bind.insert(1234);
        let bind_joined = AppPolicy::join_ports(&policy.tcp_bind);
        assert!(bind_joined.contains("1234"));
    }

    /// Example DB interaction test. Make sure your DB and test data exist.
    #[test]
    fn test_db_interaction() -> Result<()> {
        let app_name = "test_db_interaction_app";

        // Create a test policy with a few entries
        let mut policy = AppPolicy::default_policy();
        policy.ro_paths.insert(PathBuf::from("/test/db/path"));
        policy.rw_paths.insert(PathBuf::from("/test/db/rw"));
        policy.tcp_bind.insert(9090);
        policy.tcp_connect.insert(9443);

        let mut client = get_db_conn()?;
        // Delete any record for this app (for testing, ignoring roles here)
        client.execute("DELETE FROM app_policy WHERE app_name = $1", &[&app_name])?;

        // Call update_policy_in_db with a dummy user.
        let dummy_user = User { user_id: 1, username: "test".into() };
        update_policy_in_db(app_name, &policy, &dummy_user)?;

        // Now fetch the policy back from DB
        let fetched_policy = fetch_policy_from_db(app_name, &dummy_user)?;
        assert_eq!(fetched_policy.ro_paths, policy.ro_paths);
        assert_eq!(fetched_policy.rw_paths, policy.rw_paths);
        assert_eq!(fetched_policy.tcp_bind, policy.tcp_bind);
        assert_eq!(fetched_policy.tcp_connect, policy.tcp_connect);

        // Clean up afterward
        client.execute("DELETE FROM app_policy WHERE app_name = $1", &[&app_name])?;
        Ok(())
    }

    /// Verifies that parse_denied_lines picks up a denied path from our mock log.
    #[test]
    fn test_parse_denied_lines() -> Result<()> {
        use std::fs::File;
        use std::io::Write;
        use tempfile::TempDir;

        let tempdir = TempDir::new()?;
        let mock_file_path = tempdir.path().join("mock_sandbox_test.log");

        // Write a line that `parse_denied_lines` should recognize as a denial.
        {
            let mut file = File::create(&mock_file_path)?;
            writeln!(
                file,
                r#"openat(AT_FDCWD, "/some/denied/path", O_RDONLY) = -1 EACCES (Permission denied)"#
            )?;
        }

        // parse_denied_lines now returns a HashSet<String>, so we check using string membership
        let results = parse_denied_lines(tempdir.path(), "mock_sandbox_test.log")?;
        assert_eq!(results.len(), 1);
        assert!(results.contains("/some/denied/path"));

        Ok(())
    }
}use anyhow::{anyhow, Context, Result};
use bcrypt::verify;
use dialoguer::{Confirm, Input, Password, Select};
use landlock::{
    Access, AccessFs, AccessNet, ABI, NetPort, PathBeneath, PathFd, Ruleset, RulesetStatus,
    RulesetAttr, RulesetCreatedAttr,
};
use postgres::{Config, NoTls};
use regex::Regex;
use std::collections::HashSet;
use std::env;
use std::fs;
use std::io::{BufRead, BufReader};
use std::os::unix::fs::PermissionsExt;
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};
use hostname::get as get_hostname_raw;
use dotenv::dotenv;
use r2d2::Pool;
use r2d2_postgres::PostgresConnectionManager;
use once_cell::sync::Lazy;
use tempfile::TempDir;

// -----------------------------------------------------------------------
// Production code begins here.
// -----------------------------------------------------------------------

#[derive(Debug)]
struct AppPolicy {
    ro_paths: HashSet<PathBuf>,
    rw_paths: HashSet<PathBuf>,
    tcp_bind: HashSet<u16>,
    tcp_connect: HashSet<u16>,
    allowed_ips: HashSet<String>,
    allowed_domains: HashSet<String>,
}

#[derive(Debug)]
struct User {
    user_id: i32,
    #[allow(dead_code)]
    username: String,
}

impl AppPolicy {

    fn default_policy_for_role(role_id: i32) -> Result<Self> {
        let mut conn = get_db_conn().context("Failed to get DB connection for fetching default policy")?;

        let query = "
            SELECT default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains
            FROM default_policies
            WHERE role_id = $1
        ";

        let row = conn.query_one(query, &[&role_id])
            .context("Failed to fetch default policy from database")?;

        let ro_paths = parse_paths(row.get("default_ro"));
        let rw_paths = parse_paths(row.get("default_rw"));
        let tcp_bind = parse_ports(row.get("tcp_bind"));
        let tcp_connect = parse_ports(row.get("tcp_connect"));
        let allowed_ips = parse_ips(row.get("allowed_ips"));
        let allowed_domains = parse_domains(row.get("allowed_domains"));

        Ok(Self {
            ro_paths,
            rw_paths,
            tcp_bind,
            tcp_connect,
            allowed_ips,
            allowed_domains,
        })
    }
        

    fn join_ips(ips: &HashSet<String>) -> String {
        ips.iter().cloned().collect::<Vec<_>>().join(":")
    }

    fn join_domains(domains: &HashSet<String>) -> String {
        domains.iter().cloned().collect::<Vec<_>>().join(":")
    }

    fn contains_path(&self, path: &Path) -> bool {
        self.ro_paths.contains(path) || self.rw_paths.contains(path)
    }

    fn join_paths(paths: &HashSet<PathBuf>) -> String {
        paths
            .iter()
            .map(|p| p.to_string_lossy().into_owned())
            .collect::<Vec<_>>()
            .join(":")
    }

    fn join_ports(ports: &HashSet<u16>) -> String {
        ports
            .iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(":")
    }
}

// Our global static pool
static POOL: Lazy<Pool<PostgresConnectionManager<NoTls>>> = Lazy::new(|| {
    dotenv().ok();

    let host = env::var("DB_HOST").unwrap_or_else(|_| "127.0.0.1".to_string());
    let port = env::var("DB_PORT").unwrap_or_else(|_| "5432".to_string());
    let user = env::var("DB_USER").unwrap_or_else(|_| "sandboxuser".to_string());
    let pass = env::var("DB_PASS").unwrap_or_else(|_| "supernanny".to_string());
    let dbname = env::var("DB_NAME").unwrap_or_else(|_| "sandboxdb".to_string());

    let mut pg_config = Config::new();
    pg_config
        .host(&host)
        .port(port.parse().unwrap_or(5432))
        .user(&user)
        .password(&pass)
        .dbname(&dbname);

    let manager = PostgresConnectionManager::new(pg_config, NoTls);

    Pool::builder()
        .max_size(10)
        .build(manager)
        .expect("Failed to create pool.")
});

pub fn get_db_conn() -> Result<r2d2::PooledConnection<PostgresConnectionManager<NoTls>>> {
    POOL.get().context("Failed to get DB connection from pool")
}

// -----------------------------------------------------------------------
// RBAC Functions
// -----------------------------------------------------------------------

fn authenticate_user(username: &str, password: &str) -> Result<User> {
    let mut conn = get_db_conn().context("Failed to get DB connection for authentication")?;

    let row = conn.query_opt(
        "SELECT user_id, password_hash FROM users WHERE username = $1",
        &[&username],
    )
    .context("Authentication query failed")?
    .ok_or_else(|| anyhow!("User not found"))?;

    let stored_hash: String = row.get(1);
    if verify(password, &stored_hash).map_err(|e| anyhow!("Password verification failed: {}", e))? {
        Ok(User {
            user_id: row.get(0),
            username: username.to_string(),
        })
    } else {
        Err(anyhow!("Invalid credentials"))
    }
}

fn has_permission(user_id: i32, permission: &str) -> Result<bool> {
    let mut conn = get_db_conn().context("Failed to get DB connection for permission check")?;
    let count: i64 = conn.query_one(
        r#"
        SELECT COUNT(*) FROM role_permissions
        WHERE role_id IN (
            SELECT role_id FROM user_roles WHERE user_id = $1
        )
        AND permission_id = (
            SELECT permission_id FROM permissions WHERE permission_name = $2
        )
        "#,
        &[&user_id, &permission],
    )?
    .get(0);

    Ok(count > 0)
}

// -----------------------------------------------------------------------
// DB Functions
// -----------------------------------------------------------------------

fn fetch_policy_from_db(app: &str, user: &User) -> Result<AppPolicy> {
    let mut client = get_db_conn().context("Failed to get DB connection for policy fetch")?;

    // Get user's roles (assuming single role for simplicity)
    let roles: Vec<i32> = client.query(
        "SELECT r.role_id FROM roles r
         JOIN user_roles ur ON r.role_id = ur.role_id
         WHERE ur.user_id = $1",
        &[&user.user_id],
    )?
    .iter()
    .map(|row| row.get(0))
    .collect();

    // Try each role until we find a policy
    for &role_id in &roles {
        let query = "SELECT default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains
                     FROM app_policy
                     WHERE app_name = $1 AND role_id = $2";

        if let Some(row) = client.query_opt(query, &[&app, &role_id])? {
            // Parse and return policy if found
            let ro = parse_paths(row.get(0));
            let rw = parse_paths(row.get(1));
            let bind = parse_ports(row.get(2));
            let connect = parse_ports(row.get(3));
            let allowed_ips = parse_ips(row.get(4));
            let allowed_domains = parse_domains(row.get(5));

            return Ok(AppPolicy {
                ro_paths: ro,
                rw_paths: rw,
                tcp_bind: bind,
                tcp_connect: connect,
                allowed_ips: allowed_ips,
                allowed_domains: allowed_domains,
            });
        }
    }

    // Fallback to default policy for the user's role if no role-specific policy found
    let default_role_id = roles.first().copied().unwrap_or(0); // Use the first role or handle accordingly
    AppPolicy::default_policy_for_role(default_role_id)
}



// Helper function to parse domains
fn parse_domains(domains: String) -> HashSet<String> {
    domains.split(':')
        .filter(|s| !s.is_empty())
        .map(String::from)
        .collect()
}


// Helper function to parse IPs
fn parse_ips(ips: String) -> HashSet<String> {
    ips.split(':')
        .filter(|s| !s.is_empty())
        .map(String::from)
        .collect()
}



// Helper functions
fn parse_paths(paths: String) -> HashSet<PathBuf> {
    paths.split(':')
        .filter(|s| !s.is_empty())
        .map(PathBuf::from)
        .collect()
}

fn parse_ports(ports: String) -> HashSet<u16> {
    ports.split(':')
        .filter_map(|s| s.parse().ok())
        .collect()
}

fn update_policy_in_db(app: &str, policy: &AppPolicy, user: &User) -> Result<()> {
    if !has_permission(user.user_id, "manage_policies")? {
        return Err(anyhow!("Insufficient permissions to modify policies"));
    }

    let mut conn = get_db_conn().context("Failed to get DB connection for policy update")?;
    let mut tx = conn.transaction().context("Failed to start transaction")?;

    // Retrieve the user's role (assume one primary role per user)
    let role_id: i32 = tx.query_one(
        "SELECT r.role_id FROM roles r
         JOIN user_roles ur ON r.role_id = ur.role_id
         WHERE ur.user_id = $1 LIMIT 1",
        &[&user.user_id],
    )?.get(0);

    let sql = r#"
    INSERT INTO app_policy
    (app_name, role_id, default_ro, default_rw, tcp_bind, tcp_connect, allowed_ips, allowed_domains, updated_at)
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())
    ON CONFLICT (app_name, role_id) DO UPDATE SET
        default_ro = EXCLUDED.default_ro,
        default_rw = EXCLUDED.default_rw,
        tcp_bind = EXCLUDED.tcp_bind,
        tcp_connect = EXCLUDED.tcp_connect,
        allowed_ips = EXCLUDED.allowed_ips,
        allowed_domains = EXCLUDED.allowed_domains,
        updated_at = NOW()
    "#;

    tx.execute(
        sql,
        &[
            &app,
            &role_id,
            &AppPolicy::join_paths(&policy.ro_paths),
            &AppPolicy::join_paths(&policy.rw_paths),
            &AppPolicy::join_ports(&policy.tcp_bind),
            &AppPolicy::join_ports(&policy.tcp_connect),
            &AppPolicy::join_ips(&policy.allowed_ips),
            &AppPolicy::join_domains(&policy.allowed_domains), // Use join_domains here
        ],
    )
    .with_context(|| format!("Failed to update policy for app '{}' and role_id '{}'", app, role_id))?;

    tx.commit().context("Failed to commit policy update")?;

    log_event(
        user.user_id,
        app,
        Path::new("policy"),
        "policy_update",
        "success",
    )?;

    Ok(())
}


// -----------------------------------------------------------------------
// Logging
// -----------------------------------------------------------------------

fn get_hostname() -> String {
    get_hostname_raw()
        .unwrap_or_else(|_| "unknown".into())
        .to_string_lossy()
        .into_owned()
}

fn log_event(
    user_id: i32,
    app: &str,
    path: &Path,
    operation: &str,
    result: &str,
) -> Result<()> {
    let hostname = get_hostname();
    let denied_path = path.to_string_lossy().into_owned();

    let mut conn = get_db_conn().context("Failed to get DB connection for logging")?;
    let mut tx = conn.transaction().context("Failed to start logging transaction")?;

    let sql = r#"
        INSERT INTO sandbox_events
        (hostname, app_name, denied_path, operation, result, user_id)
        VALUES ($1, $2, $3, $4, $5, $6)
    "#;

    tx.execute(
        sql,
        &[&hostname, &app, &denied_path, &operation, &result, &user_id],
    )
    .with_context(|| {
        format!(
            "Failed to log event: app={}, path={}, op={}",
            app, denied_path, operation
        )
    })?;

    tx.commit().context("Failed to commit log entry")?;
    Ok(())
}


// -----------------------------------------------------------------------
// Validation and Landlock
// -----------------------------------------------------------------------

/// Validate that `path_str` is an existing executable file.
/// Returns a canonicalized PathBuf on success.
pub fn validate_executable_path(path_str: &str) -> Result<std::path::PathBuf> {
    let path = PathBuf::from(path_str);

    if !path.exists() {
        return Err(anyhow!("Executable path does not exist: {}", path_str));
    }

    let meta = fs::metadata(&path)
        .with_context(|| format!("Failed to read metadata for path '{}'", path_str))?;

    if !meta.is_file() {
        return Err(anyhow!("Path is not a regular file: {}", path_str));
    }

    #[cfg(unix)]
    {
        let perms = meta.permissions();
        let mode = perms.mode();
        if (mode & 0o111) == 0 {
            return Err(anyhow!("File is not executable: {}", path_str));
        }
    }

    let canonical = fs::canonicalize(&path)
        .with_context(|| format!("Failed to canonicalize path '{}'", path_str))?;

    Ok(canonical)
}

fn enforce_landlock(policy: &AppPolicy) -> Result<()> {
    let abi = ABI::V5;
    let base = Ruleset::default()
        .handle_access(AccessFs::from_all(abi))?
        .handle_access(AccessNet::BindTcp)?
        .handle_access(AccessNet::ConnectTcp)?;

    let mut created = base.create()
        .context("Failed to create Landlock ruleset (check if Landlock is supported)")?;

    // Add read-only paths
    for path in &policy.ro_paths {
        if let Ok(canonical_path) = fs::canonicalize(path) {
            let fd = PathFd::new(canonical_path.as_os_str())
                .with_context(|| format!("Could not create PathFd for '{}'", canonical_path.display()))?;
            let rule = PathBeneath::new(fd, AccessFs::from_read(abi));
            created = created.add_rule(rule)
                .with_context(|| format!("Could not add read-only rule for '{}'", canonical_path.display()))?;
        }
    }

    // Add read-write paths
    for path in &policy.rw_paths {
        if let Ok(canonical_path) = fs::canonicalize(path) {
            let fd = PathFd::new(canonical_path.as_os_str())
                .with_context(|| format!("Could not create PathFd for '{}'", canonical_path.display()))?;
            let rule = PathBeneath::new(fd, AccessFs::from_all(abi));
            created = created.add_rule(rule)
                .with_context(|| format!("Could not add read/write rule for '{}'", canonical_path.display()))?;
        }
    }

    // Add TCP rules
    for port in &policy.tcp_bind {
        created = created.add_rule(NetPort::new(*port, AccessNet::BindTcp))
            .with_context(|| format!("Could not add TCP bind rule for port {}", port))?;
    }
    for port in &policy.tcp_connect {
        created = created.add_rule(NetPort::new(*port, AccessNet::ConnectTcp))
            .with_context(|| format!("Could not add TCP connect rule for port {}", port))?;
    }

    let status = created.restrict_self()
        .context("Failed to restrict self with Landlock ruleset")?;
    if status.ruleset == RulesetStatus::NotEnforced {
        return Err(anyhow!("Landlock is not supported by the running kernel"));
    }

    println!("Landlock ruleset enforced successfully.");
    Ok(())
}

// -----------------------------------------------------------------------
// run_sandbox_run_mode + parse_denied_lines + process_denials
// -----------------------------------------------------------------------

fn run_sandbox_run_mode(
    app_path: &Path,
    app_args: &[String],
    policy: &AppPolicy,
    log_file_prefix: &str,
) -> Result<(ExitStatus, TempDir)> {
    let tempdir = TempDir::new()
        .context("Failed to create temporary directory for strace logs")?;
    let log_prefix_path = tempdir.path().join(log_file_prefix);
    let log_prefix_str = log_prefix_path.to_string_lossy().to_string();

    // Prepare environment variables for the child
    let mut child_env = env::vars().collect::<Vec<(String, String)>>();
    child_env.push(("LL_FS_RO".into(), AppPolicy::join_paths(&policy.ro_paths)));
    child_env.push(("LL_FS_RW".into(), AppPolicy::join_paths(&policy.rw_paths)));
    child_env.push(("LL_TCP_BIND".into(), AppPolicy::join_ports(&policy.tcp_bind)));
    child_env.push(("LL_TCP_CONNECT".into(), AppPolicy::join_ports(&policy.tcp_connect)));
    child_env.push(("LL_ALLOWED_IPS".into(), AppPolicy::join_ips(&policy.allowed_ips)));
    child_env.push(("LL_ALLOWED_DOMAINS".into(), AppPolicy::join_domains(&policy.allowed_domains)));

    let current_exe = env::current_exe()
        .context("Failed to get current executable for strace invocation")?;

    let status = Command::new("strace")
        .args(&["-ff", "-yy", 
                "-e", "trace=file,process,openat,getdents,stat,connect,socket,bind"])
        .arg("-o")
        .arg(&log_prefix_str)
        .arg(&current_exe)
        .arg("--sandbox")
        .arg(app_path)
        .args(app_args)
        .env_clear()
        .envs(child_env)
        .status()
        .with_context(|| format!("Failed to spawn strace for '{}'", app_path.display()))?;

    Ok((status, tempdir))
}

fn parse_denied_lines(log_dir: &Path, prefix: &str) -> Result<HashSet<String>> {
    // Regex for file-related syscalls
    let path_re = Regex::new(
        r#"(?x)
        ^
        (?:
           openat\(.*?,\s*"([^"]+)" |
           (?:open|stat|execve|access|readlink)\("([^"]+)" |
           getdents(?:64)?\(.*?,\s*"([^"]+)"
        )
        "#,
    )
    .context("Failed to compile syscall path regex")?;

    // New regex for network syscalls (connect or bind)
    let net_re = Regex::new(
        r#"(?x)
        ^
        (?:
           (?:connect|bind)\(.*?sin_port=htons\((\d+)\)
        )
        "#,
    )
    .context("Failed to compile network syscall regex")?;

    let mut denials = HashSet::new();

    let entries = fs::read_dir(log_dir)
        .with_context(|| format!("Failed to read directory '{}'", log_dir.display()))?;
    for entry_result in entries {
        let entry = entry_result
            .with_context(|| format!("Error iterating over directory '{}'", log_dir.display()))?;
        let fname = entry.file_name().to_string_lossy().to_string();
        if !fname.starts_with(prefix) {
            continue;
        }

        let file = fs::File::open(entry.path())
            .with_context(|| format!("Failed to open strace log file '{}'", entry.path().display()))?;
        for line_result in BufReader::new(file).lines() {
            let line = line_result
                .with_context(|| format!("Failed to read line in '{}'", entry.path().display()))?;

            // Only process lines that contain a denial error.
            if !(line.contains("EACCES") || line.contains("EPERM")) {
                continue;
            }

            // Try matching a file-based syscall.
            if let Some(caps) = path_re.captures(&line) {
                let path_str = caps.get(1)
                    .or_else(|| caps.get(2))
                    .or_else(|| caps.get(3))
                    .map(|m| m.as_str())
                    .unwrap_or("");
                if !path_str.is_empty() {
                    denials.insert(path_str.to_string());
                    continue;
                }
            }
            // If not a file syscall, try matching network-related syscalls.
            if let Some(caps) = net_re.captures(&line) {
                if let Some(port_match) = caps.get(1) {
                    let port = port_match.as_str();
                    // Prefix network events with "tcp:" to mark them.
                    denials.insert(format!("tcp:{}", port));
                    continue;
                }
            }
        }
    }

    Ok(denials)
}

fn process_denials(
    log_dir: &Path,
    prefix: &str,
    policy: &mut AppPolicy,
    app: &str,
    user: &User,
) -> Result<bool> {
    // Now we get a HashSet<String> that may contain file paths and "tcp:" entries.
    let denied_entries = parse_denied_lines(log_dir, prefix)
        .with_context(|| format!("Failed to parse denied lines for prefix '{}'", prefix))?;

    let mut updated = false;
    let can_manage = has_permission(user.user_id, "manage_policies")?;

    for entry in denied_entries {
        if entry.starts_with("tcp:") {
            // Process network denials.
            let port_str = entry.trim_start_matches("tcp:");
            if let Ok(port) = port_str.parse::<u16>() {
                // Check if the port is already allowed.
                if policy.tcp_bind.contains(&port) || policy.tcp_connect.contains(&port) {
                    continue;
                }
                if can_manage {
                    let choices = &["Allow TCP Bind", "Allow TCP Connect", "Deny"];
                    let selection = Select::new()
                        .with_prompt(format!(
                            "TCP connection denied for port {}. Allow as:",
                            port
                        ))
                        .items(choices)
                        .default(2)
                        .interact()
                        .context("User prompt failed")?;
                    match selection {
                        0 => {
                            policy.tcp_bind.insert(port);
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "granted_tcp_bind",
                            )?;
                            updated = true;
                        }
                        1 => {
                            policy.tcp_connect.insert(port);
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "granted_tcp_connect",
                            )?;
                            updated = true;
                        }
                        _ => {
                            log_event(
                                user.user_id,
                                app,
                                Path::new(&format!("tcp:{}", port)),
                                "syscall",
                                "denied",
                            )?;
                        }
                    }
                } else {
                    log_event(
                        user.user_id,
                        app,
                        Path::new(&format!("tcp:{}", port)),
                        "syscall",
                        "denied",
                    )?;
                }
            }
        } else {
            // Process filesystem denials as before.
            let path = PathBuf::from(&entry);
            if policy.contains_path(&path) {
                continue;
            }
            let final_path = match fs::canonicalize(&path) {
                Ok(resolved) => resolved,
                Err(_) => path.clone(),
            };
            if can_manage {
                let choices = &["Read-Only", "Read-Write", "Deny"];
                let selection = Select::new()
                    .with_prompt(format!(
                        "Access denied for {}. Allow as:",
                        final_path.display()
                    ))
                    .items(choices)
                    .default(2)
                    .interact()
                    .context("User prompt failed")?;
                match selection {
                    0 => {
                        policy.ro_paths.insert(final_path.clone());
                        log_event(
                            user.user_id,
                            app,
                            &final_path,
                            "syscall",
                            "granted_ro",
                        )?;
                        updated = true;
                    }
                    1 => {
                        policy.rw_paths.insert(final_path.clone());
                        log_event(
                            user.user_id,
                            app,
                            &final_path,
                            "syscall",
                            "granted_rw",
                        )?;
                        updated = true;
                    }
                    _ => {
                        log_event(
                            user.user_id,
                            app,
                            &final_path,
                            "syscall",
                            "denied",
                        )?;
                    }
                }
            } else {
                log_event(
                    user.user_id,
                    app,
                    &final_path,
                    "syscall",
                    "denied",
                )?;
            }
        }
    }

    Ok(updated && can_manage) // Only true if changes were made AND user has permissions
}

// -----------------------------------------------------------------------
// management_flow and sandbox_main
// -----------------------------------------------------------------------

fn management_flow() -> Result<()> {
    // Authenticate user
    let username = Input::<String>::new()
        .with_prompt("Username")
        .interact()
        .context("Failed to read username")?;

    let password = Password::new()
        .with_prompt("Password")
        .interact()
        .context("Failed to read password")?;

    let user = authenticate_user(&username, &password)
        .context("Authentication failed")?;

    // Check execution permission
    if !has_permission(user.user_id, "execute_apps")? {
        return Err(anyhow!("Insufficient permissions to execute applications"));
    }

    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        return Err(anyhow!("Usage: {} <APP> [ARGS...]", args[0]));
    }
    let raw_app = &args[1];
    let app_args = &args[2..];

    let mut policy = fetch_policy_from_db(raw_app, &user)
        .with_context(|| format!("Failed to fetch policy for '{}'", raw_app))?;

    let first_prefix = "sandboxer_first.log";
    let (first_status, first_tempdir) = run_sandbox_run_mode(Path::new(raw_app), app_args, &policy, first_prefix)
        .with_context(|| format!("Failed first run for '{}'", raw_app))?;

    let has_denials = !parse_denied_lines(first_tempdir.path(), first_prefix)?.is_empty();
    let needs_processing = !first_status.success() || has_denials;

    if needs_processing {
        println!("Processing denials...");
        let changed = process_denials(
            first_tempdir.path(),
            first_prefix,
            &mut policy,
            raw_app,
            &user,
        )
        .context("Denial processing failed")?;

        if changed {
            update_policy_in_db(raw_app, &policy, &user)
                .context("Policy update failed")?;

            let do_second_run = Confirm::new()
                .with_prompt("Would you like to run the application again with the updated policy?")
                .default(true)
                .interact()
                .context("Failed to prompt for second run")?;

            if do_second_run {
                let second_prefix = "sandboxer_second.log";
                let (second_status, second_tempdir) = run_sandbox_run_mode(
                    Path::new(raw_app),
                    app_args,
                    &policy,
                    second_prefix
                )
                .with_context(|| format!("Failed during second run for '{}'", raw_app))?;

                let second_denials = parse_denied_lines(second_tempdir.path(), second_prefix)
                    .context("Failed to parse second run denials")?;

                if second_denials.is_empty() && second_status.success() {
                    println!("Second run successful. No denied operations.");
                } else {
                    println!("Denied operations still detected. Further updates may be needed.");
                }
            } else {
                println!("Exiting without second run.");
            }
        } else {
            // Handle cases where no changes were made
            if has_permission(user.user_id, "manage_policies")? {
                println!("No policy changes made. Skipping second run.");
            } else {
                println!("Insufficient permissions for policy updates. Skipping second run.");
            }
        }
    } else {
        println!("Program executed successfully under sandbox.");
    }

    Ok(())
}

fn sandbox_main() -> ! {
    let args: Vec<String> = std::env::args().collect();

    if args.len() < 3 {
        eprintln!("Usage: {} --sandbox <APP> [ARGS...]", args[0]);
        std::process::exit(1);
    }

    let cmd = &args[2];
    let cmd_args = &args[3..];

    let policy = AppPolicy {
        ro_paths: std::env::var("LL_FS_RO").unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(Into::into)
            .collect(),
        rw_paths: std::env::var("LL_FS_RW").unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(Into::into)
            .collect(),
        tcp_bind: std::env::var("LL_TCP_BIND").unwrap_or_default()
            .split(':')
            .filter_map(|s| s.parse().ok())
            .collect(),
        tcp_connect: std::env::var("LL_TCP_CONNECT").unwrap_or_default()
            .split(':')
            .filter_map(|s| s.parse().ok())
            .collect(),
        allowed_ips: std::env::var("LL_ALLOWED_IPS").unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect(),
        allowed_domains: std::env::var("LL_ALLOWED_DOMAINS").unwrap_or_default()
            .split(':')
            .filter(|s| !s.is_empty())
            .map(String::from)
            .collect(),
    };
    

    if let Err(e) = enforce_landlock(&policy) {
        eprintln!("Failed to enforce Landlock rules: {}", e);
        std::process::exit(1);
    }

    match Command::new(cmd).args(cmd_args).status() {
        Ok(status) => std::process::exit(status.code().unwrap_or(1)),
        Err(e) => {
            eprintln!("Failed to execute '{}': {}", cmd, e);
            std::process::exit(1);
        }
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    if args.len() >= 2 && args[1] == "--sandbox" {
        sandbox_main();
    } else {
        if let Err(e) = management_flow() {
            eprintln!("Error in management flow: {:?}", e);  // [EH-IMPROVED] Provide debug info
            std::process::exit(1);
        }
    }
}

// -----------------------------------------------------------------------
// Test code begins here.
// -----------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    // Basic logic tests for AppPolicy
    #[test]
    fn test_default_policy() -> Result<()> {
        let policy = AppPolicy::default_policy_for_role(1)?;
        assert!(policy.ro_paths.contains(Path::new("/bin")));
        assert!(policy.ro_paths.contains(Path::new("/etc")));
        assert!(policy.rw_paths.contains(Path::new("/tmp")));
        Ok(())
    }
    

    #[test]
    fn test_join_paths_and_ports() -> Result<()> {
        let mut policy = AppPolicy::default_policy_for_role(1)?;
        policy.ro_paths.insert(PathBuf::from("/home"));
        let ro_joined = AppPolicy::join_paths(&policy.ro_paths);
        assert!(ro_joined.contains("/home"));
    
        policy.tcp_bind.insert(1234);
        let bind_joined = AppPolicy::join_ports(&policy.tcp_bind);
        assert!(bind_joined.contains("1234"));
        Ok(())
    }
    

    #[test]
    fn test_db_interaction() -> Result<()> {
        let app_name = "test_db_interaction_app";
    
        // Assuming role_id 1 is a valid role in your test database
        let mut policy = AppPolicy::default_policy_for_role(1)?;
        policy.ro_paths.insert(PathBuf::from("/test/db/path"));
        policy.rw_paths.insert(PathBuf::from("/test/db/rw"));
        policy.tcp_bind.insert(9090);
        policy.tcp_connect.insert(9443);
        policy.allowed_ips.insert("192.168.1.1".to_string());
        policy.allowed_domains.insert("google.com".to_string());
    
        let mut client = get_db_conn()?;
        // Delete any record for this app (for testing, we ignore the role)
        client.execute("DELETE FROM app_policy WHERE app_name = $1", &[&app_name])?;
    
        // Call update_policy_in_db with a dummy user.
        update_policy_in_db(app_name, &policy, &User { user_id: 1, username: "test".to_string() })?;
    
        // Fetch the policy for this app.
        let fetched_policy = fetch_policy_from_db(app_name, &User { user_id: 1, username: "test".to_string() })?;
        assert_eq!(fetched_policy.ro_paths, policy.ro_paths);
        assert_eq!(fetched_policy.rw_paths, policy.rw_paths);
        assert_eq!(fetched_policy.tcp_bind, policy.tcp_bind);
        assert_eq!(fetched_policy.tcp_connect, policy.tcp_connect);
        assert_eq!(fetched_policy.allowed_ips, policy.allowed_ips);
        assert_eq!(fetched_policy.allowed_domains, policy.allowed_domains);
    
        client.execute("DELETE FROM app_policy WHERE app_name = $1", &[&app_name])?;
        Ok(())
    }
    
    

    // parse_denied_lines() test with mock log files
    #[test]
    fn test_parse_denied_lines() -> Result<()> {
        use std::fs::File;
        use std::io::Write;
        use tempfile::TempDir;

        let tempdir = TempDir::new()?;
        let mock_file_path = tempdir.path().join("mock_sandbox_test.log");

        {
            let mut file = File::create(&mock_file_path)?;
            writeln!(
                file,
                r#"openat(AT_FDCWD, "/some/denied/path", O_RDONLY) = -1 EACCES (Permission denied)"#
            )?;
        }

        let result = parse_denied_lines(tempdir.path(), "mock_sandbox_test.log")?;
        assert_eq!(result.len(), 1);
        // Compare with a string slice, because result is a HashSet<String>
        assert!(result.contains("/some/denied/path"));
        Ok(())
    }
}/* automatically generated by rust-bindgen 0.69.4 */

pub const __BITS_PER_LONG: u32 = 64;
pub const __BITS_PER_LONG_LONG: u32 = 64;
pub const __FD_SETSIZE: u32 = 1024;
pub const LANDLOCK_CREATE_RULESET_VERSION: u32 = 1;
pub const LANDLOCK_ACCESS_FS_EXECUTE: u32 = 1;
pub const LANDLOCK_ACCESS_FS_WRITE_FILE: u32 = 2;
pub const LANDLOCK_ACCESS_FS_READ_FILE: u32 = 4;
pub const LANDLOCK_ACCESS_FS_READ_DIR: u32 = 8;
pub const LANDLOCK_ACCESS_FS_REMOVE_DIR: u32 = 16;
pub const LANDLOCK_ACCESS_FS_REMOVE_FILE: u32 = 32;
pub const LANDLOCK_ACCESS_FS_MAKE_CHAR: u32 = 64;
pub const LANDLOCK_ACCESS_FS_MAKE_DIR: u32 = 128;
pub const LANDLOCK_ACCESS_FS_MAKE_REG: u32 = 256;
pub const LANDLOCK_ACCESS_FS_MAKE_SOCK: u32 = 512;
pub const LANDLOCK_ACCESS_FS_MAKE_FIFO: u32 = 1024;
pub const LANDLOCK_ACCESS_FS_MAKE_BLOCK: u32 = 2048;
pub const LANDLOCK_ACCESS_FS_MAKE_SYM: u32 = 4096;
pub const LANDLOCK_ACCESS_FS_REFER: u32 = 8192;
pub const LANDLOCK_ACCESS_FS_TRUNCATE: u32 = 16384;
pub const LANDLOCK_ACCESS_FS_IOCTL_DEV: u32 = 32768;
pub const LANDLOCK_ACCESS_NET_BIND_TCP: u32 = 1;
pub const LANDLOCK_ACCESS_NET_CONNECT_TCP: u32 = 2;
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_old_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ulong;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_mode_t = ::std::os::raw::c_uint;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_int;
pub type __kernel_uid_t = ::std::os::raw::c_uint;
pub type __kernel_gid_t = ::std::os::raw::c_uint;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_size_t = __kernel_ulong_t;
pub type __kernel_ssize_t = __kernel_long_t;
pub type __kernel_ptrdiff_t = __kernel_long_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__kernel_fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_old_time_t = __kernel_long_t;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_time64_t = ::std::os::raw::c_longlong;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __s128 = i128;
pub type __u128 = u128;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
pub type __poll_t = ::std::os::raw::c_uint;
#[doc = " struct landlock_ruleset_attr - Ruleset definition\n\n Argument of sys_landlock_create_ruleset().  This structure can grow in\n future versions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct landlock_ruleset_attr {
    #[doc = " @handled_access_fs: Bitmask of actions (cf. `Filesystem flags`_)\n that is handled by this ruleset and should then be forbidden if no\n rule explicitly allow them: it is a deny-by-default list that should\n contain as much Landlock access rights as possible. Indeed, all\n Landlock filesystem access rights that are not part of\n handled_access_fs are allowed.  This is needed for backward\n compatibility reasons.  One exception is the\n %LANDLOCK_ACCESS_FS_REFER access right, which is always implicitly\n handled, but must still be explicitly handled to add new rules with\n this access right."]
    pub handled_access_fs: __u64,
    #[doc = " @handled_access_net: Bitmask of actions (cf. `Network flags`_)\n that is handled by this ruleset and should then be forbidden if no\n rule explicitly allow them."]
    pub handled_access_net: __u64,
}
#[test]
fn bindgen_test_layout_landlock_ruleset_attr() {
    const UNINIT: ::std::mem::MaybeUninit<landlock_ruleset_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<landlock_ruleset_attr>(),
        16usize,
        concat!("Size of: ", stringify!(landlock_ruleset_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<landlock_ruleset_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(landlock_ruleset_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handled_access_fs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_ruleset_attr),
            "::",
            stringify!(handled_access_fs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handled_access_net) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_ruleset_attr),
            "::",
            stringify!(handled_access_net)
        )
    );
}
#[doc = " @LANDLOCK_RULE_PATH_BENEATH: Type of a &struct\n landlock_path_beneath_attr ."]
pub const landlock_rule_type_LANDLOCK_RULE_PATH_BENEATH: landlock_rule_type = 1;
#[doc = " @LANDLOCK_RULE_NET_PORT: Type of a &struct\n landlock_net_port_attr ."]
pub const landlock_rule_type_LANDLOCK_RULE_NET_PORT: landlock_rule_type = 2;
#[doc = " enum landlock_rule_type - Landlock rule type\n\n Argument of sys_landlock_add_rule()."]
pub type landlock_rule_type = ::std::os::raw::c_uint;
#[doc = " struct landlock_path_beneath_attr - Path hierarchy definition\n\n Argument of sys_landlock_add_rule()."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct landlock_path_beneath_attr {
    #[doc = " @allowed_access: Bitmask of allowed actions for this file hierarchy\n (cf. `Filesystem flags`_)."]
    pub allowed_access: __u64,
    #[doc = " @parent_fd: File descriptor, preferably opened with ``O_PATH``,\n which identifies the parent directory of a file hierarchy, or just a\n file."]
    pub parent_fd: __s32,
}
#[test]
fn bindgen_test_layout_landlock_path_beneath_attr() {
    const UNINIT: ::std::mem::MaybeUninit<landlock_path_beneath_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<landlock_path_beneath_attr>(),
        12usize,
        concat!("Size of: ", stringify!(landlock_path_beneath_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<landlock_path_beneath_attr>(),
        1usize,
        concat!("Alignment of ", stringify!(landlock_path_beneath_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_path_beneath_attr),
            "::",
            stringify!(allowed_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parent_fd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_path_beneath_attr),
            "::",
            stringify!(parent_fd)
        )
    );
}
#[doc = " struct landlock_net_port_attr - Network port definition\n\n Argument of sys_landlock_add_rule()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct landlock_net_port_attr {
    #[doc = " @allowed_access: Bitmask of allowed access network for a port\n (cf. `Network flags`_)."]
    pub allowed_access: __u64,
    #[doc = " @port: Network port in host endianness.\n\n It should be noted that port 0 passed to :manpage:`bind(2)` will\n bind to an available port from a specific port range. This can be\n configured thanks to the ``/proc/sys/net/ipv4/ip_local_port_range``\n sysctl (also used for IPv6). A Landlock rule with port 0 and the\n ``LANDLOCK_ACCESS_NET_BIND_TCP`` right means that requesting to bind\n on port 0 is allowed and it will automatically translate to binding\n on the related port range."]
    pub port: __u64,
}
#[test]
fn bindgen_test_layout_landlock_net_port_attr() {
    const UNINIT: ::std::mem::MaybeUninit<landlock_net_port_attr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<landlock_net_port_attr>(),
        16usize,
        concat!("Size of: ", stringify!(landlock_net_port_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<landlock_net_port_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(landlock_net_port_attr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allowed_access) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_net_port_attr),
            "::",
            stringify!(allowed_access)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(landlock_net_port_attr),
            "::",
            stringify!(port)
        )
    );
}
#[allow(dead_code)]
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(non_upper_case_globals)]
mod landlock;

#[rustfmt::skip]
pub use self::landlock::{
    landlock_net_port_attr,
    landlock_path_beneath_attr,
    landlock_rule_type,
    landlock_rule_type_LANDLOCK_RULE_NET_PORT,
    landlock_rule_type_LANDLOCK_RULE_PATH_BENEATH,
    landlock_ruleset_attr,
    LANDLOCK_ACCESS_FS_EXECUTE,
    LANDLOCK_ACCESS_FS_WRITE_FILE,
    LANDLOCK_ACCESS_FS_READ_FILE,
    LANDLOCK_ACCESS_FS_READ_DIR,
    LANDLOCK_ACCESS_FS_REMOVE_DIR,
    LANDLOCK_ACCESS_FS_REMOVE_FILE,
    LANDLOCK_ACCESS_FS_MAKE_CHAR,
    LANDLOCK_ACCESS_FS_MAKE_DIR,
    LANDLOCK_ACCESS_FS_MAKE_REG,
    LANDLOCK_ACCESS_FS_MAKE_SOCK,
    LANDLOCK_ACCESS_FS_MAKE_FIFO,
    LANDLOCK_ACCESS_FS_MAKE_BLOCK,
    LANDLOCK_ACCESS_FS_MAKE_SYM,
    LANDLOCK_ACCESS_FS_REFER,
    LANDLOCK_ACCESS_FS_TRUNCATE,
    LANDLOCK_ACCESS_FS_IOCTL_DEV,
    LANDLOCK_ACCESS_NET_BIND_TCP,
    LANDLOCK_ACCESS_NET_CONNECT_TCP,
    LANDLOCK_CREATE_RULESET_VERSION,
};

use libc::{
    __u32, c_int, c_void, size_t, syscall, SYS_landlock_add_rule, SYS_landlock_create_ruleset,
    SYS_landlock_restrict_self,
};

#[rustfmt::skip]
pub unsafe fn landlock_create_ruleset(attr: *const landlock_ruleset_attr, size: size_t,
                                      flags: __u32) -> c_int {
    syscall(SYS_landlock_create_ruleset, attr, size, flags) as c_int
}

#[rustfmt::skip]
pub unsafe fn landlock_add_rule(ruleset_fd: c_int, rule_type: landlock_rule_type,
                                rule_attr: *const c_void, flags: __u32) -> c_int {
    syscall(SYS_landlock_add_rule, ruleset_fd, rule_type, rule_attr, flags) as c_int
}

pub unsafe fn landlock_restrict_self(ruleset_fd: c_int, flags: __u32) -> c_int {
    syscall(SYS_landlock_restrict_self, ruleset_fd, flags) as c_int
}
use crate::compat::private::OptionCompatLevelMut;
use crate::{
    uapi, Access, AddRuleError, AddRulesError, CompatError, CompatLevel, CompatResult, CompatState,
    Compatible, HandleAccessError, HandleAccessesError, PathBeneathError, PathFdError,
    PrivateAccess, PrivateRule, Rule, Ruleset, RulesetCreated, RulesetError, TailoredCompatLevel,
    TryCompat, ABI,
};
use enumflags2::{bitflags, make_bitflags, BitFlags};
use std::fs::OpenOptions;
use std::io::Error;
use std::mem::zeroed;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::{AsFd, AsRawFd, BorrowedFd, OwnedFd};
use std::path::Path;

#[cfg(test)]
use crate::{RulesetAttr, RulesetCreatedAttr};
#[cfg(test)]
use strum::IntoEnumIterator;

/// File system access right.
///
/// Each variant of `AccessFs` is an [access right](https://www.kernel.org/doc/html/latest/userspace-api/landlock.html#access-rights)
/// for the file system.
/// A set of access rights can be created with [`BitFlags<AccessFs>`](BitFlags).
///
/// # Example
///
/// ```
/// use landlock::{ABI, Access, AccessFs, BitFlags, make_bitflags};
///
/// let exec = AccessFs::Execute;
///
/// let exec_set: BitFlags<AccessFs> = exec.into();
///
/// let file_content = make_bitflags!(AccessFs::{Execute | WriteFile | ReadFile});
///
/// let fs_v1 = AccessFs::from_all(ABI::V1);
///
/// let without_exec = fs_v1 & !AccessFs::Execute;
///
/// assert_eq!(fs_v1 | AccessFs::Refer, AccessFs::from_all(ABI::V2));
/// ```
///
/// # Warning
///
/// To avoid unknown restrictions **don't use `BitFlags::<AccessFs>::all()` nor `BitFlags::ALL`**,
/// but use a version you tested and vetted instead,
/// for instance [`AccessFs::from_all(ABI::V1)`](Access::from_all).
/// Direct use of **the [`BitFlags`] API is deprecated**.
/// See [`ABI`] for the rationale and help to test it.
#[bitflags]
#[repr(u64)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[non_exhaustive]
pub enum AccessFs {
    /// Execute a file.
    Execute = uapi::LANDLOCK_ACCESS_FS_EXECUTE as u64,
    /// Open a file with write access.
    ///
    /// # Note
    ///
    /// Certain operations (such as [`std::fs::write`]) may also require [`AccessFs::Truncate`] since [`ABI::V3`].
    WriteFile = uapi::LANDLOCK_ACCESS_FS_WRITE_FILE as u64,
    /// Open a file with read access.
    ReadFile = uapi::LANDLOCK_ACCESS_FS_READ_FILE as u64,
    /// Open a directory or list its content.
    ReadDir = uapi::LANDLOCK_ACCESS_FS_READ_DIR as u64,
    /// Remove an empty directory or rename one.
    RemoveDir = uapi::LANDLOCK_ACCESS_FS_REMOVE_DIR as u64,
    /// Unlink (or rename) a file.
    RemoveFile = uapi::LANDLOCK_ACCESS_FS_REMOVE_FILE as u64,
    /// Create (or rename or link) a character device.
    MakeChar = uapi::LANDLOCK_ACCESS_FS_MAKE_CHAR as u64,
    /// Create (or rename) a directory.
    MakeDir = uapi::LANDLOCK_ACCESS_FS_MAKE_DIR as u64,
    /// Create (or rename or link) a regular file.
    MakeReg = uapi::LANDLOCK_ACCESS_FS_MAKE_REG as u64,
    /// Create (or rename or link) a UNIX domain socket.
    MakeSock = uapi::LANDLOCK_ACCESS_FS_MAKE_SOCK as u64,
    /// Create (or rename or link) a named pipe.
    MakeFifo = uapi::LANDLOCK_ACCESS_FS_MAKE_FIFO as u64,
    /// Create (or rename or link) a block device.
    MakeBlock = uapi::LANDLOCK_ACCESS_FS_MAKE_BLOCK as u64,
    /// Create (or rename or link) a symbolic link.
    MakeSym = uapi::LANDLOCK_ACCESS_FS_MAKE_SYM as u64,
    /// Link or rename a file from or to a different directory.
    Refer = uapi::LANDLOCK_ACCESS_FS_REFER as u64,
    /// Truncate a file with `truncate(2)`, `ftruncate(2)`, `creat(2)`, or `open(2)` with `O_TRUNC`.
    Truncate = uapi::LANDLOCK_ACCESS_FS_TRUNCATE as u64,
    /// Send IOCL commands to a device file.
    IoctlDev = uapi::LANDLOCK_ACCESS_FS_IOCTL_DEV as u64,
}

impl Access for AccessFs {
    /// Union of [`from_read()`](AccessFs::from_read) and [`from_write()`](AccessFs::from_write).
    fn from_all(abi: ABI) -> BitFlags<Self> {
        // An empty access-right would be an error if passed to the kernel, but because the kernel
        // doesn't support Landlock, no Landlock syscall should be called.  try_compat() should
        // also return RestrictionStatus::Unrestricted when called with unsupported/empty
        // access-rights.
        Self::from_read(abi) | Self::from_write(abi)
    }
}

impl AccessFs {
    // Roughly read (i.e. not all FS actions are handled).
    /// Gets the access rights identified as read-only according to a specific ABI.
    /// Exclusive with [`from_write()`](AccessFs::from_write).
    pub fn from_read(abi: ABI) -> BitFlags<Self> {
        match abi {
            ABI::Unsupported => BitFlags::EMPTY,
            ABI::V1 | ABI::V2 | ABI::V3 | ABI::V4 | ABI::V5 => make_bitflags!(AccessFs::{
                Execute
                | ReadFile
                | ReadDir
            }),
        }
    }

    // Roughly write (i.e. not all FS actions are handled).
    /// Gets the access rights identified as write-only according to a specific ABI.
    /// Exclusive with [`from_read()`](AccessFs::from_read).
    pub fn from_write(abi: ABI) -> BitFlags<Self> {
        match abi {
            ABI::Unsupported => BitFlags::EMPTY,
            ABI::V1 => make_bitflags!(AccessFs::{
                WriteFile
                | RemoveDir
                | RemoveFile
                | MakeChar
                | MakeDir
                | MakeReg
                | MakeSock
                | MakeFifo
                | MakeBlock
                | MakeSym
            }),
            ABI::V2 => Self::from_write(ABI::V1) | AccessFs::Refer,
            ABI::V3 | ABI::V4 => Self::from_write(ABI::V2) | AccessFs::Truncate,
            ABI::V5 => Self::from_write(ABI::V4) | AccessFs::IoctlDev,
        }
    }

    /// Gets the access rights legitimate for non-directory files.
    pub fn from_file(abi: ABI) -> BitFlags<Self> {
        Self::from_all(abi) & ACCESS_FILE
    }
}

#[test]
fn consistent_access_fs_rw() {
    for abi in ABI::iter() {
        let access_all = AccessFs::from_all(abi);
        let access_read = AccessFs::from_read(abi);
        let access_write = AccessFs::from_write(abi);
        assert_eq!(access_read, !access_write & access_all);
        assert_eq!(access_read | access_write, access_all);
    }
}

impl PrivateAccess for AccessFs {
    fn ruleset_handle_access(
        ruleset: &mut Ruleset,
        access: BitFlags<Self>,
    ) -> Result<(), HandleAccessesError> {
        // We need to record the requested accesses for PrivateRule::check_consistency().
        ruleset.requested_handled_fs |= access;
        ruleset.actual_handled_fs |= match access
            .try_compat(
                ruleset.compat.abi(),
                ruleset.compat.level,
                &mut ruleset.compat.state,
            )
            .map_err(HandleAccessError::Compat)?
        {
            Some(a) => a,
            None => return Ok(()),
        };
        Ok(())
    }

    fn into_add_rules_error(error: AddRuleError<Self>) -> AddRulesError {
        AddRulesError::Fs(error)
    }

    fn into_handle_accesses_error(error: HandleAccessError<Self>) -> HandleAccessesError {
        HandleAccessesError::Fs(error)
    }
}

// TODO: Make ACCESS_FILE a property of AccessFs.
// TODO: Add tests for ACCESS_FILE.
const ACCESS_FILE: BitFlags<AccessFs> = make_bitflags!(AccessFs::{
    ReadFile | WriteFile | Execute | Truncate | IoctlDev
});

// XXX: What should we do when a stat call failed?
fn is_file<F>(fd: F) -> Result<bool, Error>
where
    F: AsFd,
{
    unsafe {
        let mut stat = zeroed();
        match libc::fstat(fd.as_fd().as_raw_fd(), &mut stat) {
            0 => Ok((stat.st_mode & libc::S_IFMT) != libc::S_IFDIR),
            _ => Err(Error::last_os_error()),
        }
    }
}

/// Landlock rule for a file hierarchy.
///
/// # Example
///
/// ```
/// use landlock::{AccessFs, PathBeneath, PathFd, PathFdError};
///
/// fn home_dir() -> Result<PathBeneath<PathFd>, PathFdError> {
///     Ok(PathBeneath::new(PathFd::new("/home")?, AccessFs::ReadDir))
/// }
/// ```
#[cfg_attr(test, derive(Debug))]
pub struct PathBeneath<F> {
    attr: uapi::landlock_path_beneath_attr,
    // Ties the lifetime of a file descriptor to this object.
    parent_fd: F,
    allowed_access: BitFlags<AccessFs>,
    compat_level: Option<CompatLevel>,
}

impl<F> PathBeneath<F>
where
    F: AsFd,
{
    /// Creates a new `PathBeneath` rule identifying the `parent` directory of a file hierarchy,
    /// or just a file, and allows `access` on it.
    /// The `parent` file descriptor will be automatically closed with the returned `PathBeneath`.
    pub fn new<A>(parent: F, access: A) -> Self
    where
        A: Into<BitFlags<AccessFs>>,
    {
        PathBeneath {
            // Invalid access rights until as_ptr() is called.
            attr: unsafe { zeroed() },
            parent_fd: parent,
            allowed_access: access.into(),
            compat_level: None,
        }
    }
}

impl<F> TryCompat<AccessFs> for PathBeneath<F>
where
    F: AsFd,
{
    fn try_compat_children<L>(
        mut self,
        abi: ABI,
        parent_level: L,
        compat_state: &mut CompatState,
    ) -> Result<Option<Self>, CompatError<AccessFs>>
    where
        L: Into<CompatLevel>,
    {
        // Checks with our own compatibility level, if any.
        self.allowed_access = match self.allowed_access.try_compat(
            abi,
            self.tailored_compat_level(parent_level),
            compat_state,
        )? {
            Some(a) => a,
            None => return Ok(None),
        };
        Ok(Some(self))
    }

    fn try_compat_inner(
        &mut self,
        _abi: ABI,
    ) -> Result<CompatResult<AccessFs>, CompatError<AccessFs>> {
        // Gets subset of valid accesses according the FD type.
        let valid_access =
            if is_file(&self.parent_fd).map_err(|e| PathBeneathError::StatCall { source: e })? {
                self.allowed_access & ACCESS_FILE
            } else {
                self.allowed_access
            };

        if self.allowed_access != valid_access {
            let error = PathBeneathError::DirectoryAccess {
                access: self.allowed_access,
                incompatible: self.allowed_access ^ valid_access,
            }
            .into();
            self.allowed_access = valid_access;
            // Linux would return EINVAL.
            Ok(CompatResult::Partial(error))
        } else {
            Ok(CompatResult::Full)
        }
    }
}

#[test]
fn path_beneath_try_compat_children() {
    use crate::*;

    // AccessFs::Refer is not handled by ABI::V1 and only for directories.
    let access_file = AccessFs::ReadFile | AccessFs::Refer;

    // Test error ordering with ABI::V1
    let mut ruleset = Ruleset::from(ABI::V1).handle_access(access_file).unwrap();
    // Do not actually perform any syscall.
    ruleset.compat.state = CompatState::Dummy;
    assert!(matches!(
        RulesetCreated::new(ruleset, -1)
            .set_compatibility(CompatLevel::HardRequirement)
            .add_rule(PathBeneath::new(PathFd::new("/dev/null").unwrap(), access_file))
            .unwrap_err(),
        RulesetError::AddRules(AddRulesError::Fs(AddRuleError::Compat(
            CompatError::PathBeneath(PathBeneathError::DirectoryAccess { access, incompatible })
        ))) if access == access_file && incompatible == AccessFs::Refer
    ));

    // Test error ordering with ABI::V2
    let mut ruleset = Ruleset::from(ABI::V2).handle_access(access_file).unwrap();
    // Do not actually perform any syscall.
    ruleset.compat.state = CompatState::Dummy;
    assert!(matches!(
        RulesetCreated::new(ruleset, -1)
            .set_compatibility(CompatLevel::HardRequirement)
            .add_rule(PathBeneath::new(PathFd::new("/dev/null").unwrap(), access_file))
            .unwrap_err(),
        RulesetError::AddRules(AddRulesError::Fs(AddRuleError::Compat(
            CompatError::PathBeneath(PathBeneathError::DirectoryAccess { access, incompatible })
        ))) if access == access_file && incompatible == AccessFs::Refer
    ));
}

#[test]
fn path_beneath_try_compat() {
    use crate::*;

    let abi = ABI::V1;

    for file in &["/etc/passwd", "/dev/null"] {
        let mut compat_state = CompatState::Init;
        let ro_access = AccessFs::ReadDir | AccessFs::ReadFile;
        assert!(matches!(
            PathBeneath::new(PathFd::new(file).unwrap(), ro_access)
                .try_compat(abi, CompatLevel::HardRequirement, &mut compat_state)
                .unwrap_err(),
            CompatError::PathBeneath(PathBeneathError::DirectoryAccess { access, incompatible })
                if access == ro_access && incompatible == AccessFs::ReadDir
        ));

        let mut compat_state = CompatState::Init;
        assert!(matches!(
            PathBeneath::new(PathFd::new(file).unwrap(), BitFlags::EMPTY)
                .try_compat(abi, CompatLevel::BestEffort, &mut compat_state)
                .unwrap_err(),
            CompatError::Access(AccessError::Empty)
        ));
    }

    let full_access = AccessFs::from_all(ABI::V1);
    for compat_level in &[
        CompatLevel::BestEffort,
        CompatLevel::SoftRequirement,
        CompatLevel::HardRequirement,
    ] {
        let mut compat_state = CompatState::Init;
        let mut path_beneath = PathBeneath::new(PathFd::new("/").unwrap(), full_access)
            .try_compat(abi, *compat_level, &mut compat_state)
            .unwrap()
            .unwrap();
        assert_eq!(compat_state, CompatState::Full);

        // Without synchronization.
        let raw_access = path_beneath.attr.allowed_access;
        assert_eq!(raw_access, 0);

        // Synchronize the inner attribute buffer.
        let _ = path_beneath.as_ptr();
        let raw_access = path_beneath.attr.allowed_access;
        assert_eq!(raw_access, full_access.bits());
    }
}

impl<F> OptionCompatLevelMut for PathBeneath<F> {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat_level
    }
}

impl<F> OptionCompatLevelMut for &mut PathBeneath<F> {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat_level
    }
}

impl<F> Compatible for PathBeneath<F> {}

impl<F> Compatible for &mut PathBeneath<F> {}

#[test]
fn path_beneath_compatibility() {
    let mut path = PathBeneath::new(PathFd::new("/").unwrap(), AccessFs::from_all(ABI::V1));
    let path_ref = &mut path;

    let level = path_ref.as_option_compat_level_mut();
    assert_eq!(level, &None);
    assert_eq!(
        <Option<CompatLevel> as Into<CompatLevel>>::into(*level),
        CompatLevel::BestEffort
    );

    path_ref.set_compatibility(CompatLevel::SoftRequirement);
    assert_eq!(
        path_ref.as_option_compat_level_mut(),
        &Some(CompatLevel::SoftRequirement)
    );

    path.set_compatibility(CompatLevel::HardRequirement);
}

// It is useful for documentation generation to explicitely implement Rule for every types, instead
// of doing it generically.
impl<F> Rule<AccessFs> for PathBeneath<F> where F: AsFd {}

impl<F> PrivateRule<AccessFs> for PathBeneath<F>
where
    F: AsFd,
{
    const TYPE_ID: uapi::landlock_rule_type = uapi::landlock_rule_type_LANDLOCK_RULE_PATH_BENEATH;

    fn as_ptr(&mut self) -> *const libc::c_void {
        self.attr.parent_fd = self.parent_fd.as_fd().as_raw_fd();
        self.attr.allowed_access = self.allowed_access.bits();
        &self.attr as *const _ as _
    }

    fn check_consistency(&self, ruleset: &RulesetCreated) -> Result<(), AddRulesError> {
        // Checks that this rule doesn't contain a superset of the access-rights handled by the
        // ruleset.  This check is about requested access-rights but not actual access-rights.
        // Indeed, we want to get a deterministic behavior, i.e. not based on the running kernel
        // (which is handled by Ruleset and RulesetCreated).
        if ruleset.requested_handled_fs.contains(self.allowed_access) {
            Ok(())
        } else {
            Err(AddRuleError::UnhandledAccess {
                access: self.allowed_access,
                incompatible: self.allowed_access & !ruleset.requested_handled_fs,
            }
            .into())
        }
    }
}

#[test]
fn path_beneath_check_consistency() {
    use crate::*;

    let ro_access = AccessFs::ReadDir | AccessFs::ReadFile;
    let rx_access = AccessFs::Execute | AccessFs::ReadFile;
    assert!(matches!(
        Ruleset::from(ABI::Unsupported)
            .handle_access(ro_access)
            .unwrap()
            .create()
            .unwrap()
            .add_rule(PathBeneath::new(PathFd::new("/").unwrap(), rx_access))
            .unwrap_err(),
        RulesetError::AddRules(AddRulesError::Fs(AddRuleError::UnhandledAccess { access, incompatible }))
            if access == rx_access && incompatible == AccessFs::Execute
    ));
}

/// Simple helper to open a file or a directory with the `O_PATH` flag.
///
/// This is the recommended way to identify a path
/// and manage the lifetime of the underlying opened file descriptor.
/// Indeed, using other [`AsFd`] implementations such as [`File`] brings more complexity
/// and may lead to unexpected errors (e.g., denied access).
///
/// [`File`]: std::fs::File
///
/// # Example
///
/// ```
/// use landlock::{AccessFs, PathBeneath, PathFd, PathFdError};
///
/// fn allowed_root_dir(access: AccessFs) -> Result<PathBeneath<PathFd>, PathFdError> {
///     let fd = PathFd::new("/")?;
///     Ok(PathBeneath::new(fd, access))
/// }
/// ```
#[cfg_attr(test, derive(Debug))]
pub struct PathFd {
    fd: OwnedFd,
}

impl PathFd {
    pub fn new<T>(path: T) -> Result<Self, PathFdError>
    where
        T: AsRef<Path>,
    {
        Ok(PathFd {
            fd: OpenOptions::new()
                .read(true)
                // If the O_PATH is not supported, it is automatically ignored (Linux < 2.6.39).
                .custom_flags(libc::O_PATH | libc::O_CLOEXEC)
                .open(path.as_ref())
                .map_err(|e| PathFdError::OpenCall {
                    source: e,
                    path: path.as_ref().into(),
                })?
                .into(),
        })
    }
}

impl AsFd for PathFd {
    fn as_fd(&self) -> BorrowedFd<'_> {
        self.fd.as_fd()
    }
}

#[test]
fn path_fd() {
    use std::fs::File;
    use std::io::Read;

    PathBeneath::new(PathFd::new("/").unwrap(), AccessFs::Execute);
    PathBeneath::new(File::open("/").unwrap(), AccessFs::Execute);

    let mut buffer = [0; 1];
    // Checks that PathFd really returns an FD opened with O_PATH (Bad file descriptor error).
    File::from(PathFd::new("/etc/passwd").unwrap().fd)
        .read(&mut buffer)
        .unwrap_err();
}

/// Helper to quickly create an iterator of PathBeneath rules.
///
/// # Note
///
/// Landlock rules operate on file descriptors, not paths. This is a helper to create rules based on paths. **It
/// silently ignores paths that cannot be opened**, and automatically adjusts access rights according to file types when
/// possible.
///
/// # Example
///
/// ```
/// use landlock::{
///     ABI, Access, AccessFs, Ruleset, RulesetAttr, RulesetCreatedAttr, RulesetStatus, RulesetError,
///     path_beneath_rules,
/// };
///
/// fn restrict_thread() -> Result<(), RulesetError> {
///     let abi = ABI::V1;
///     let status = Ruleset::default()
///         .handle_access(AccessFs::from_all(abi))?
///         .create()?
///         // Read-only access to /usr, /etc and /dev.
///         .add_rules(path_beneath_rules(&["/usr", "/etc", "/dev"], AccessFs::from_read(abi)))?
///         // Read-write access to /home and /tmp.
///         .add_rules(path_beneath_rules(&["/home", "/tmp"], AccessFs::from_all(abi)))?
///         .restrict_self()?;
///     match status.ruleset {
///         // The FullyEnforced case must be tested by the developer.
///         RulesetStatus::FullyEnforced => println!("Fully sandboxed."),
///         RulesetStatus::PartiallyEnforced => println!("Partially sandboxed."),
///         // Users should be warned that they are not protected.
///         RulesetStatus::NotEnforced => println!("Not sandboxed! Please update your kernel."),
///     }
///     Ok(())
/// }
/// ```
pub fn path_beneath_rules<I, P, A>(
    paths: I,
    access: A,
) -> impl Iterator<Item = Result<PathBeneath<PathFd>, RulesetError>>
where
    I: IntoIterator<Item = P>,
    P: AsRef<Path>,
    A: Into<BitFlags<AccessFs>>,
{
    let access = access.into();
    paths.into_iter().filter_map(move |p| match PathFd::new(p) {
        Ok(f) => {
            let valid_access = match is_file(&f) {
                Ok(true) => access & ACCESS_FILE,
                // If the stat call failed, let's blindly rely on the requested access rights.
                Err(_) | Ok(false) => access,
            };
            Some(Ok(PathBeneath::new(f, valid_access)))
        }
        Err(_) => None,
    })
}

#[test]
fn path_beneath_rules_iter() {
    let _ = Ruleset::default()
        .handle_access(AccessFs::from_all(ABI::V1))
        .unwrap()
        .create()
        .unwrap()
        .add_rules(path_beneath_rules(
            &["/usr", "/opt", "/does-not-exist", "/root"],
            AccessFs::Execute,
        ))
        .unwrap();
}
use crate::{uapi, Access, CompatError};

#[cfg(test)]
use std::convert::TryInto;
#[cfg(test)]
use strum::{EnumCount, IntoEnumIterator};
#[cfg(test)]
use strum_macros::{EnumCount as EnumCountMacro, EnumIter};

/// Version of the Landlock [ABI](https://en.wikipedia.org/wiki/Application_binary_interface).
///
/// `ABI` enables getting the features supported by a specific Landlock ABI
/// (without relying on the kernel version which may not be accessible or patched).
/// For example, [`AccessFs::from_all(ABI::V1)`](Access::from_all)
/// gets all the file system access rights defined by the first version.
///
/// Without `ABI`, it would be hazardous to rely on the the full set of access flags
/// (e.g., `BitFlags::<AccessFs>::all()` or `BitFlags::ALL`),
/// a moving target that would change the semantics of your Landlock rule
/// when migrating to a newer version of this crate.
/// Indeed, a simple `cargo update` or `cargo install` run by any developer
/// can result in a new version of this crate (fixing bugs or bringing non-breaking changes).
/// This crate cannot give any guarantee concerning the new restrictions resulting from
/// these unknown bits (i.e. access rights) that would not be controlled by your application but by
/// a future version of this crate instead.
/// Because we cannot know what the effect on your application of an unknown restriction would be
/// when handling an untested Landlock access right (i.e. denied-by-default access),
/// it could trigger bugs in your application.
///
/// This crate provides a set of tools to sandbox as much as possible
/// while guaranteeing a consistent behavior thanks to the [`Compatible`] methods.
/// You should also test with different relevant kernel versions,
/// see [landlock-test-tools](https://github.com/landlock-lsm/landlock-test-tools) and
/// [CI integration](https://github.com/landlock-lsm/rust-landlock/pull/41).
///
/// This way, we can have the guarantee that the use of a set of tested Landlock ABI works as
/// expected because features brought by newer Landlock ABI will never be enabled by default
/// (cf. [Linux kernel compatibility contract](https://docs.kernel.org/userspace-api/landlock.html#compatibility)).
///
/// In a nutshell, test the access rights you request on a kernel that support them and
/// on a kernel that doesn't support them.
#[cfg_attr(
    test,
    derive(Debug, PartialEq, Eq, PartialOrd, EnumIter, EnumCountMacro)
)]
#[derive(Copy, Clone)]
#[non_exhaustive]
pub enum ABI {
    /// Kernel not supporting Landlock, either because it is not built with Landlock
    /// or Landlock is not enabled at boot.
    Unsupported = 0,
    /// First Landlock ABI, introduced with
    /// [Linux 5.13](https://git.kernel.org/stable/c/17ae69aba89dbfa2139b7f8024b757ab3cc42f59).
    V1 = 1,
    /// Second Landlock ABI, introduced with
    /// [Linux 5.19](https://git.kernel.org/stable/c/cb44e4f061e16be65b8a16505e121490c66d30d0).
    V2 = 2,
    /// Third Landlock ABI, introduced with
    /// [Linux 6.2](https://git.kernel.org/stable/c/299e2b1967578b1442128ba8b3e86ed3427d3651).
    V3 = 3,
    /// Fourth Landlock ABI, introduced with
    /// [Linux 6.7](https://git.kernel.org/stable/c/136cc1e1f5be75f57f1e0404b94ee1c8792cb07d).
    V4 = 4,
    /// Fifth Landlock ABI, introduced with
    /// [Linux 6.10](https://git.kernel.org/stable/c/2fc0e7892c10734c1b7c613ef04836d57d4676d5).
    V5 = 5,
}

impl ABI {
    // Must remain private to avoid inconsistent behavior by passing Ok(self) to a builder method,
    // e.g. to make it impossible to call ruleset.handle_fs(ABI::new_current()?)
    fn new_current() -> Self {
        ABI::from(unsafe {
            // Landlock ABI version starts at 1 but errno is only set for negative values.
            uapi::landlock_create_ruleset(
                std::ptr::null(),
                0,
                uapi::LANDLOCK_CREATE_RULESET_VERSION,
            )
        })
    }

    // There is no way to not publicly expose an implementation of an external trait such as
    // From<i32>.  See RFC https://github.com/rust-lang/rfcs/pull/2529
    fn from(value: i32) -> ABI {
        match value {
            // The only possible error values should be EOPNOTSUPP and ENOSYS, but let's interpret
            // all kind of errors as unsupported.
            n if n <= 0 => ABI::Unsupported,
            1 => ABI::V1,
            2 => ABI::V2,
            3 => ABI::V3,
            4 => ABI::V4,
            // Returns the greatest known ABI.
            _ => ABI::V5,
        }
    }

    #[cfg(test)]
    fn is_known(value: i32) -> bool {
        value > 0 && value < ABI::COUNT as i32
    }
}

#[test]
fn abi_from() {
    // EOPNOTSUPP (-95), ENOSYS (-38)
    for n in [-95, -38, -1, 0] {
        assert_eq!(ABI::from(n), ABI::Unsupported);
    }

    let mut last_i = 1;
    let mut last_abi = ABI::Unsupported;
    for (i, abi) in ABI::iter().enumerate() {
        last_i = i.try_into().unwrap();
        last_abi = abi;
        assert_eq!(ABI::from(last_i), last_abi);
    }

    assert_eq!(ABI::from(last_i + 1), last_abi);
    assert_eq!(ABI::from(9), last_abi);
}

#[test]
fn known_abi() {
    assert!(!ABI::is_known(-1));
    assert!(!ABI::is_known(0));
    assert!(!ABI::is_known(99));

    let mut last_i = -1;
    for (i, _) in ABI::iter().enumerate().skip(1) {
        last_i = i as i32;
        assert!(ABI::is_known(last_i));
    }
    assert!(!ABI::is_known(last_i + 1));
}

#[cfg(test)]
lazy_static! {
    static ref TEST_ABI: ABI = match std::env::var("LANDLOCK_CRATE_TEST_ABI") {
        Ok(s) => {
            let n = s.parse::<i32>().unwrap();
            if ABI::is_known(n) || n == 0 {
                ABI::from(n)
            } else {
                panic!("Unknown ABI: {n}");
            }
        }
        Err(std::env::VarError::NotPresent) => ABI::new_current(),
        Err(e) => panic!("Failed to read LANDLOCK_CRATE_TEST_ABI: {e}"),
    };
}

#[cfg(test)]
pub(crate) fn can_emulate(mock: ABI, partial_support: ABI, full_support: Option<ABI>) -> bool {
    mock < partial_support
        || mock <= *TEST_ABI
        || if let Some(full) = full_support {
            full <= *TEST_ABI
        } else {
            partial_support <= *TEST_ABI
        }
}

#[cfg(test)]
pub(crate) fn get_errno_from_landlock_status() -> Option<i32> {
    use std::io::Error;

    if unsafe {
        uapi::landlock_create_ruleset(std::ptr::null(), 0, uapi::LANDLOCK_CREATE_RULESET_VERSION)
    } < 0
    {
        match Error::last_os_error().raw_os_error() {
            // Returns ENOSYS when the kernel is not built with Landlock support,
            // or EOPNOTSUPP when Landlock is supported but disabled at boot time.
            ret @ Some(libc::ENOSYS | libc::EOPNOTSUPP) => ret,
            // Other values can only come from bogus seccomp filters or debug tampering.
            _ => unreachable!(),
        }
    } else {
        None
    }
}

#[test]
fn current_kernel_abi() {
    // Ensures that the tested Landlock ABI is the latest known version supported by the running
    // kernel.  If this test failed, you need set the LANDLOCK_CRATE_TEST_ABI environment variable
    // to the Landlock ABI version supported by your kernel.  With a missing variable, the latest
    // Landlock ABI version known by this crate is automatically set.
    // From Linux 5.13 to 5.18, you need to run: LANDLOCK_CRATE_TEST_ABI=1 cargo test
    assert_eq!(*TEST_ABI, ABI::new_current());
}

// CompatState is not public outside this crate.
/// Returned by ruleset builder.
#[cfg_attr(test, derive(Debug))]
#[derive(Copy, Clone, PartialEq, Eq)]
pub enum CompatState {
    /// Initial undefined state.
    Init,
    /// All requested restrictions are enforced.
    Full,
    /// Some requested restrictions are enforced, following a best-effort approach.
    Partial,
    /// The running system doesn't support Landlock.
    No,
    /// Final unsupported state.
    Dummy,
}

impl CompatState {
    fn update(&mut self, other: Self) {
        *self = match (*self, other) {
            (CompatState::Init, other) => other,
            (CompatState::Dummy, _) => CompatState::Dummy,
            (_, CompatState::Dummy) => CompatState::Dummy,
            (CompatState::No, CompatState::No) => CompatState::No,
            (CompatState::Full, CompatState::Full) => CompatState::Full,
            (_, _) => CompatState::Partial,
        }
    }
}

#[test]
fn compat_state_update_1() {
    let mut state = CompatState::Full;

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Full);

    state.update(CompatState::No);
    assert_eq!(state, CompatState::Partial);

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Partial);

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Partial);

    state.update(CompatState::No);
    assert_eq!(state, CompatState::Partial);

    state.update(CompatState::Dummy);
    assert_eq!(state, CompatState::Dummy);

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Dummy);
}

#[test]
fn compat_state_update_2() {
    let mut state = CompatState::Full;

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Full);

    state.update(CompatState::No);
    assert_eq!(state, CompatState::Partial);

    state.update(CompatState::Full);
    assert_eq!(state, CompatState::Partial);
}

#[cfg_attr(test, derive(Debug, PartialEq))]
#[derive(Copy, Clone)]
pub(crate) struct Compatibility {
    abi: ABI,
    pub(crate) level: Option<CompatLevel>,
    pub(crate) state: CompatState,
}

impl From<ABI> for Compatibility {
    fn from(abi: ABI) -> Self {
        Compatibility {
            abi,
            level: Default::default(),
            state: CompatState::Init,
        }
    }
}

impl Compatibility {
    // Compatibility is a semi-opaque struct.
    #[allow(clippy::new_without_default)]
    pub(crate) fn new() -> Self {
        ABI::new_current().into()
    }

    pub(crate) fn update(&mut self, state: CompatState) {
        self.state.update(state);
    }

    pub(crate) fn abi(&self) -> ABI {
        self.abi
    }
}

pub(crate) mod private {
    use crate::CompatLevel;

    pub trait OptionCompatLevelMut {
        fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel>;
    }
}

/// Properly handles runtime unsupported features.
///
/// This guarantees consistent behaviors across crate users
/// and runtime kernels even if this crate get new features.
/// It eases backward compatibility and enables future-proofness.
///
/// Landlock is a security feature designed to help improve security of a running system
/// thanks to application developers.
/// To protect users as much as possible,
/// compatibility with the running system should then be handled in a best-effort way,
/// contrary to common system features.
/// In some circumstances
/// (e.g. applications carefully designed to only be run with a specific set of kernel features),
/// it may be required to error out if some of these features are not available
/// and will then not be enforced.
pub trait Compatible: Sized + private::OptionCompatLevelMut {
    /// To enable a best-effort security approach,
    /// Landlock features that are not supported by the running system
    /// are silently ignored by default,
    /// which is a sane choice for most use cases.
    /// However, on some rare circumstances,
    /// developers may want to have some guarantees that their applications
    /// will not run if a certain level of sandboxing is not possible.
    /// If we really want to error out when not all our requested requirements are met,
    /// then we can configure it with `set_compatibility()`.
    ///
    /// The `Compatible` trait is implemented for all object builders
    /// (e.g. [`Ruleset`](crate::Ruleset)).
    /// Such builders have a set of methods to incrementally build an object.
    /// These build methods rely on kernel features that may not be available at runtime.
    /// The `set_compatibility()` method enables to control the effect of
    /// the following build method calls starting after the `set_compatibility()` call.
    /// Such effect can be:
    /// * to silently ignore unsupported features
    ///   and continue building ([`CompatLevel::BestEffort`]);
    /// * to silently ignore unsupported features
    ///   and ignore the whole build ([`CompatLevel::SoftRequirement`]);
    /// * to return an error for any unsupported feature ([`CompatLevel::HardRequirement`]).
    ///
    /// Taking [`Ruleset`](crate::Ruleset) as an example,
    /// the [`handle_access()`](crate::RulesetAttr::handle_access()) build method
    /// returns a [`Result`] that can be [`Err(RulesetError)`](crate::RulesetError)
    /// with a nested [`CompatError`].
    /// Such error can only occur with a running Linux kernel not supporting the requested
    /// Landlock accesses *and* if the current compatibility level is
    /// [`CompatLevel::HardRequirement`].
    /// However, such error is not possible with [`CompatLevel::BestEffort`]
    /// nor [`CompatLevel::SoftRequirement`].
    ///
    /// The order of this call is important because
    /// it defines the behavior of the following build method calls that return a [`Result`].
    /// If `set_compatibility(CompatLevel::HardRequirement)` is called on an object,
    /// then a [`CompatError`] may be returned for the next method calls,
    /// until the next call to `set_compatibility()`.
    /// This enables to change the behavior of a set of build method calls,
    /// for instance to be sure that the sandbox will at least restrict some access rights.
    ///
    /// New objects inherit the compatibility configuration of their parents, if any.
    /// For instance, [`Ruleset::create()`](crate::Ruleset::create()) returns
    /// a [`RulesetCreated`](crate::RulesetCreated) object that inherits the
    /// `Ruleset`'s compatibility configuration.
    ///
    /// # Example with `SoftRequirement`
    ///
    /// Let's say an application legitimately needs to rename files between directories.
    /// Because of [previous Landlock limitations](https://docs.kernel.org/userspace-api/landlock.html#file-renaming-and-linking-abi-2),
    /// this was forbidden with the [first version of Landlock](ABI::V1),
    /// but it is now handled starting with the [second version](ABI::V2).
    /// For this use case, we only want the application to be sandboxed
    /// if we have the guarantee that it will not break a legitimate usage (i.e. rename files).
    /// We then create a ruleset which will either support file renaming
    /// (thanks to [`AccessFs::Refer`](crate::AccessFs::Refer)) or silently do nothing.
    ///
    /// ```
    /// use landlock::*;
    ///
    /// fn ruleset_handling_renames() -> Result<RulesetCreated, RulesetError> {
    ///     Ok(Ruleset::default()
    ///         // This ruleset must either handle the AccessFs::Refer right,
    ///         // or it must silently ignore the whole sandboxing.
    ///         .set_compatibility(CompatLevel::SoftRequirement)
    ///         .handle_access(AccessFs::Refer)?
    ///         // However, this ruleset may also handle other (future) access rights
    ///         // if they are supported by the running kernel.
    ///         .set_compatibility(CompatLevel::BestEffort)
    ///         .handle_access(AccessFs::from_all(ABI::V5))?
    ///         .create()?)
    /// }
    /// ```
    ///
    /// # Example with `HardRequirement`
    ///
    /// Security-dedicated applications may want to ensure that
    /// an untrusted software component is subject to a minimum of restrictions before launching it.
    /// In this case, we want to create a ruleset which will at least support
    /// all restrictions provided by the [first version of Landlock](ABI::V1),
    /// and opportunistically handle restrictions supported by newer kernels.
    ///
    /// ```
    /// use landlock::*;
    ///
    /// fn ruleset_fragile() -> Result<RulesetCreated, RulesetError> {
    ///     Ok(Ruleset::default()
    ///         // This ruleset must either handle at least all accesses defined by
    ///         // the first Landlock version (e.g. AccessFs::WriteFile),
    ///         // or the following handle_access() call must return a wrapped
    ///         // AccessError<AccessFs>::Incompatible error.
    ///         .set_compatibility(CompatLevel::HardRequirement)
    ///         .handle_access(AccessFs::from_all(ABI::V1))?
    ///         // However, this ruleset may also handle new access rights
    ///         // (e.g. AccessFs::Refer defined by the second version of Landlock)
    ///         // if they are supported by the running kernel,
    ///         // but without returning any error otherwise.
    ///         .set_compatibility(CompatLevel::BestEffort)
    ///         .handle_access(AccessFs::from_all(ABI::V5))?
    ///         .create()?)
    /// }
    /// ```
    fn set_compatibility(mut self, level: CompatLevel) -> Self {
        *self.as_option_compat_level_mut() = Some(level);
        self
    }

    /// Cf. [`set_compatibility()`](Compatible::set_compatibility()):
    ///
    /// - `set_best_effort(true)` translates to `set_compatibility(CompatLevel::BestEffort)`.
    ///
    /// - `set_best_effort(false)` translates to `set_compatibility(CompatLevel::HardRequirement)`.
    #[deprecated(note = "Use set_compatibility() instead")]
    fn set_best_effort(self, best_effort: bool) -> Self
    where
        Self: Sized,
    {
        self.set_compatibility(match best_effort {
            true => CompatLevel::BestEffort,
            false => CompatLevel::HardRequirement,
        })
    }
}

#[test]
#[allow(deprecated)]
fn deprecated_set_best_effort() {
    use crate::{CompatLevel, Compatible, Ruleset};

    assert_eq!(
        Ruleset::default().set_best_effort(true).compat,
        Ruleset::default()
            .set_compatibility(CompatLevel::BestEffort)
            .compat
    );
    assert_eq!(
        Ruleset::default().set_best_effort(false).compat,
        Ruleset::default()
            .set_compatibility(CompatLevel::HardRequirement)
            .compat
    );
}

/// See the [`Compatible`] documentation.
#[cfg_attr(test, derive(EnumIter))]
#[derive(Debug, Default, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum CompatLevel {
    /// Takes into account the build requests if they are supported by the running system,
    /// or silently ignores them otherwise.
    /// Never returns a compatibility error.
    #[default]
    BestEffort,
    /// Takes into account the build requests if they are supported by the running system,
    /// or silently ignores the whole build object otherwise.
    /// Never returns a compatibility error.
    /// If not supported,
    /// the call to [`RulesetCreated::restrict_self()`](crate::RulesetCreated::restrict_self())
    /// will return a
    /// [`RestrictionStatus { ruleset: RulesetStatus::NotEnforced, no_new_privs: false, }`](crate::RestrictionStatus).
    SoftRequirement,
    /// Takes into account the build requests if they are supported by the running system,
    /// or returns a compatibility error otherwise ([`CompatError`]).
    HardRequirement,
}

impl From<Option<CompatLevel>> for CompatLevel {
    fn from(opt: Option<CompatLevel>) -> Self {
        match opt {
            None => CompatLevel::default(),
            Some(ref level) => *level,
        }
    }
}

// TailoredCompatLevel could be replaced with AsMut<Option<CompatLevel>>, but only traits defined
// in the current crate can be implemented for types defined outside of the crate.  Furthermore it
// provides a default implementation which is handy for types such as BitFlags.
pub trait TailoredCompatLevel {
    fn tailored_compat_level<L>(&mut self, parent_level: L) -> CompatLevel
    where
        L: Into<CompatLevel>,
    {
        parent_level.into()
    }
}

impl<T> TailoredCompatLevel for T
where
    Self: Compatible,
{
    // Every Compatible trait implementation returns its own compatibility level, if set.
    fn tailored_compat_level<L>(&mut self, parent_level: L) -> CompatLevel
    where
        L: Into<CompatLevel>,
    {
        // Using a mutable reference is not required but it makes the code simpler (no double AsRef
        // implementations for each Compatible types), and more importantly it guarantees
        // consistency with Compatible::set_compatibility().
        match self.as_option_compat_level_mut() {
            None => parent_level.into(),
            // Returns the most constrained compatibility level.
            Some(ref level) => parent_level.into().max(*level),
        }
    }
}

#[test]
fn tailored_compat_level() {
    use crate::{AccessFs, PathBeneath, PathFd};

    fn new_path(level: CompatLevel) -> PathBeneath<PathFd> {
        PathBeneath::new(PathFd::new("/").unwrap(), AccessFs::Execute).set_compatibility(level)
    }

    for parent_level in CompatLevel::iter() {
        assert_eq!(
            new_path(CompatLevel::BestEffort).tailored_compat_level(parent_level),
            parent_level
        );
        assert_eq!(
            new_path(CompatLevel::HardRequirement).tailored_compat_level(parent_level),
            CompatLevel::HardRequirement
        );
    }

    assert_eq!(
        new_path(CompatLevel::SoftRequirement).tailored_compat_level(CompatLevel::SoftRequirement),
        CompatLevel::SoftRequirement
    );

    for child_level in CompatLevel::iter() {
        assert_eq!(
            new_path(child_level).tailored_compat_level(CompatLevel::BestEffort),
            child_level
        );
        assert_eq!(
            new_path(child_level).tailored_compat_level(CompatLevel::HardRequirement),
            CompatLevel::HardRequirement
        );
    }
}

// CompatResult is not public outside this crate.
pub enum CompatResult<A>
where
    A: Access,
{
    // Fully matches the request.
    Full,
    // Partially matches the request.
    Partial(CompatError<A>),
    // Doesn't matches the request.
    No(CompatError<A>),
}

// TryCompat is not public outside this crate.
pub trait TryCompat<A>
where
    Self: Sized + TailoredCompatLevel,
    A: Access,
{
    fn try_compat_inner(&mut self, abi: ABI) -> Result<CompatResult<A>, CompatError<A>>;

    // Default implementation for objects without children.
    //
    // If returning something other than Ok(Some(self)), the implementation must use its own
    // compatibility level, if any, with self.tailored_compat_level(default_compat_level), and pass
    // it with the abi and compat_state to each child.try_compat().  See PathBeneath implementation
    // and the self.allowed_access.try_compat() call.
    //
    // # Warning
    //
    // Errors must be prioritized over incompatibility (i.e. return Err(e) over Ok(None)) for all
    // children.
    fn try_compat_children<L>(
        self,
        _abi: ABI,
        _parent_level: L,
        _compat_state: &mut CompatState,
    ) -> Result<Option<Self>, CompatError<A>>
    where
        L: Into<CompatLevel>,
    {
        Ok(Some(self))
    }

    // Update compat_state and return an error according to try_compat_*() error, or to the
    // compatibility level, i.e. either route compatible object or error.
    fn try_compat<L>(
        mut self,
        abi: ABI,
        parent_level: L,
        compat_state: &mut CompatState,
    ) -> Result<Option<Self>, CompatError<A>>
    where
        L: Into<CompatLevel>,
    {
        let compat_level = self.tailored_compat_level(parent_level);
        let some_inner = match self.try_compat_inner(abi) {
            Ok(CompatResult::Full) => {
                compat_state.update(CompatState::Full);
                true
            }
            Ok(CompatResult::Partial(error)) => match compat_level {
                CompatLevel::BestEffort => {
                    compat_state.update(CompatState::Partial);
                    true
                }
                CompatLevel::SoftRequirement => {
                    compat_state.update(CompatState::Dummy);
                    false
                }
                CompatLevel::HardRequirement => {
                    compat_state.update(CompatState::Dummy);
                    return Err(error);
                }
            },
            Ok(CompatResult::No(error)) => match compat_level {
                CompatLevel::BestEffort => {
                    compat_state.update(CompatState::No);
                    false
                }
                CompatLevel::SoftRequirement => {
                    compat_state.update(CompatState::Dummy);
                    false
                }
                CompatLevel::HardRequirement => {
                    compat_state.update(CompatState::Dummy);
                    return Err(error);
                }
            },
            Err(error) => {
                // Safeguard to help for test consistency.
                compat_state.update(CompatState::Dummy);
                return Err(error);
            }
        };

        // At this point, any inner error have been returned, so we can proceed with
        // try_compat_children()?.
        match self.try_compat_children(abi, compat_level, compat_state)? {
            Some(n) if some_inner => Ok(Some(n)),
            _ => Ok(None),
        }
    }
}
//! Landlock is a security feature available since Linux 5.13.
//! The goal is to enable to restrict ambient rights
//! (e.g., global filesystem access)
//! for a set of processes by creating safe security sandboxes as new security layers
//! in addition to the existing system-wide access-controls.
//! This kind of sandbox is expected to help mitigate the security impact of bugs,
//! unexpected or malicious behaviors in applications.
//! Landlock empowers any process, including unprivileged ones, to securely restrict themselves.
//! More information about Landlock can be found in the [official website](https://landlock.io).
//!
//! This crate provides a safe abstraction for the Landlock system calls, along with some helpers.
//!
//! Minimum Supported Rust Version (MSRV): 1.63
//!
//! # Use cases
//!
//! This crate is especially useful to protect users' data by sandboxing:
//! * trusted applications dealing with potentially malicious data
//!   (e.g., complex file format, network request) that could exploit security vulnerabilities;
//! * sandbox managers, container runtimes or shells launching untrusted applications.
//!
//! # Examples
//!
//! A simple example can be found with the [`path_beneath_rules()`] helper.
//! More complex examples can be found with the [`Ruleset` documentation](Ruleset)
//! and the [sandboxer example](https://github.com/landlock-lsm/rust-landlock/blob/master/examples/sandboxer.rs).
//!
//! # Current limitations
//!
//! This crate exposes the Landlock features available as of Linux 5.19
//! and then inherits some [kernel limitations](https://www.kernel.org/doc/html/latest/userspace-api/landlock.html#current-limitations)
//! that will be addressed with future kernel releases
//! (e.g., arbitrary mounts are always denied).
//!
//! # Compatibility
//!
//! Types defined in this crate are designed to enable the strictest Landlock configuration
//! for the given kernel on which the program runs.
//! In the default [best-effort](CompatLevel::BestEffort) mode,
//! [`Ruleset`] will determine compatibility
//! with the intersection of the currently running kernel's features
//! and those required by the caller.
//! This way, callers can distinguish between
//! Landlock compatibility issues inherent to the current system
//! (e.g., file names that don't exist)
//! and misconfiguration that should be fixed in the program
//! (e.g., empty or inconsistent access rights).
//! [`RulesetError`] identifies such kind of errors.
//!
//! With [`set_compatibility(CompatLevel::BestEffort)`](Compatible::set_compatibility),
//! users of the crate may mark Landlock features that are deemed required
//! and other features that may be downgraded to use lower security on systems
//! where they can't be enforced.
//! It is discouraged to compare the system's provided [Landlock ABI](ABI) version directly,
//! as it is difficult to track detailed ABI differences
//! which are handled thanks to the [`Compatible`] trait.
//!
//! To make it easier to migrate to a new version of this library,
//! we use the builder pattern
//! and designed objects to require the minimal set of method arguments.
//! Most `enum` are marked as `non_exhaustive` to enable backward-compatible evolutions.
//!
//! ## Test strategy
//!
//! Developers should test their sandboxed applications
//! with a kernel that supports all requested Landlock features
//! and check that [`RulesetCreated::restrict_self()`] returns a status matching
//! [`Ok(RestrictionStatus { ruleset: RulesetStatus::FullyEnforced, no_new_privs: true, })`](RestrictionStatus)
//! to make sure everything works as expected in an enforced sandbox.
//! Alternatively, using [`set_compatibility(CompatLevel::HardRequirement)`](Compatible::set_compatibility)
//! will immediately inform about unsupported Landlock features.
//! These configurations should only depend on the test environment
//! (e.g. [by checking an environment variable](https://github.com/landlock-lsm/rust-landlock/search?q=LANDLOCK_CRATE_TEST_ABI)).
//! However, applications should only check that no error is returned (i.e. `Ok(_)`)
//! and optionally log and inform users that the application is not fully sandboxed
//! because of missing features from the running kernel.

#[cfg(test)]
#[macro_use]
extern crate lazy_static;

pub use access::Access;
pub use compat::{CompatLevel, Compatible, ABI};
pub use enumflags2::{make_bitflags, BitFlags};
pub use errors::{
    AccessError, AddRuleError, AddRulesError, CompatError, CreateRulesetError, HandleAccessError,
    HandleAccessesError, PathBeneathError, PathFdError, RestrictSelfError, RulesetError,
};
pub use fs::{path_beneath_rules, AccessFs, PathBeneath, PathFd};
pub use net::{AccessNet, NetPort};
pub use ruleset::{
    RestrictionStatus, Rule, Ruleset, RulesetAttr, RulesetCreated, RulesetCreatedAttr,
    RulesetStatus,
};

use access::PrivateAccess;
use compat::{CompatResult, CompatState, Compatibility, TailoredCompatLevel, TryCompat};
use ruleset::PrivateRule;

#[cfg(test)]
use compat::{can_emulate, get_errno_from_landlock_status};
#[cfg(test)]
use errors::TestRulesetError;
#[cfg(test)]
use strum::IntoEnumIterator;

mod access;
mod compat;
mod errors;
mod fs;
mod net;
mod ruleset;
mod uapi;
pub mod policy_client;

#[cfg(test)]
mod tests {
    use crate::*;

    // Emulate old kernel supports.
    fn check_ruleset_support<F>(
        partial: ABI,
        full: Option<ABI>,
        check: F,
        error_if_abi_lt_partial: bool,
    ) where
        F: Fn(Ruleset) -> Result<RestrictionStatus, TestRulesetError> + Send + Copy + 'static,
    {
        // If there is no partial support, it means that `full == partial`.
        assert!(partial <= full.unwrap_or(partial));
        for abi in ABI::iter() {
            // Ensures restrict_self() is called on a dedicated thread to avoid inconsistent tests.
            let ret = std::thread::spawn(move || check(Ruleset::from(abi)))
                .join()
                .unwrap();

            // Useful for failed tests and with cargo test -- --show-output
            println!("Checking ABI {abi:?}: received {ret:#?}");
            if can_emulate(abi, partial, full) {
                if abi < partial && error_if_abi_lt_partial {
                    // TODO: Check exact error type; this may require better error types.
                    assert!(matches!(ret, Err(TestRulesetError::Ruleset(_))));
                } else {
                    let full_support = if let Some(full_inner) = full {
                        abi >= full_inner
                    } else {
                        false
                    };
                    let ruleset_status = if full_support {
                        RulesetStatus::FullyEnforced
                    } else if abi >= partial {
                        RulesetStatus::PartiallyEnforced
                    } else {
                        RulesetStatus::NotEnforced
                    };
                    println!("Expecting ruleset status {ruleset_status:?}");
                    assert!(matches!(
                        ret,
                        Ok(RestrictionStatus {
                            ruleset,
                            no_new_privs: true,
                        }) if ruleset == ruleset_status
                    ))
                }
            } else {
                // The errno value should be ENOSYS, EOPNOTSUPP, EINVAL (e.g. when an unknown
                // access right is provided), or E2BIG (e.g. when there is an unknown field in a
                // Landlock syscall attribute).
                let errno = get_errno_from_landlock_status();
                println!("Expecting error {errno:?}");
                match ret {
                    Err(TestRulesetError::Ruleset(RulesetError::CreateRuleset(
                        CreateRulesetError::CreateRulesetCall { source },
                    ))) => match (source.raw_os_error(), errno) {
                        (Some(e1), Some(e2)) => assert_eq!(e1, e2),
                        (Some(e1), None) => assert!(matches!(e1, libc::EINVAL | libc::E2BIG)),
                        _ => unreachable!(),
                    },
                    _ => unreachable!(),
                }
            }
        }
    }

    #[test]
    fn allow_root_compat() {
        let abi = ABI::V1;

        check_ruleset_support(
            abi,
            Some(abi),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::from_all(abi))?
                    .create()?
                    .add_rule(PathBeneath::new(PathFd::new("/")?, AccessFs::from_all(abi)))?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn too_much_access_rights_for_a_file() {
        let abi = ABI::V1;

        check_ruleset_support(
            abi,
            Some(abi),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::from_all(abi))?
                    .create()?
                    // Same code as allow_root_compat() but with /etc/passwd instead of /
                    .add_rule(PathBeneath::new(
                        PathFd::new("/etc/passwd")?,
                        // Only allow legitimate access rights on a file.
                        AccessFs::from_file(abi),
                    ))?
                    .restrict_self()?)
            },
            false,
        );

        check_ruleset_support(
            abi,
            None,
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::from_all(abi))?
                    .create()?
                    // Same code as allow_root_compat() but with /etc/passwd instead of /
                    .add_rule(PathBeneath::new(
                        PathFd::new("/etc/passwd")?,
                        // Tries to allow all access rights on a file.
                        AccessFs::from_all(abi),
                    ))?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn path_beneath_rules_with_too_much_access_rights_for_a_file() {
        let abi = ABI::V1;

        check_ruleset_support(
            abi,
            Some(abi),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::from_all(ABI::V1))?
                    .create()?
                    // Same code as too_much_access_rights_for_a_file() but using path_beneath_rules()
                    .add_rules(path_beneath_rules(["/etc/passwd"], AccessFs::from_all(abi)))?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn allow_root_fragile() {
        let abi = ABI::V1;

        check_ruleset_support(
            abi,
            Some(abi),
            move |ruleset: Ruleset| -> _ {
                // Sets default support requirement: abort the whole sandboxing for any Landlock error.
                Ok(ruleset
                    // Must have at least the execute check
                    .set_compatibility(CompatLevel::HardRequirement)
                    .handle_access(AccessFs::Execute)?
                    // and possibly others.
                    .set_compatibility(CompatLevel::BestEffort)
                    .handle_access(AccessFs::from_all(abi))?
                    .create()?
                    .set_no_new_privs(true)
                    .add_rule(PathBeneath::new(PathFd::new("/")?, AccessFs::from_all(abi)))?
                    .restrict_self()?)
            },
            true,
        );
    }

    #[test]
    fn ruleset_enforced() {
        let abi = ABI::V1;

        check_ruleset_support(
            abi,
            Some(abi),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    // Restricting without rule exceptions is legitimate to forbid a set of actions.
                    .handle_access(AccessFs::Execute)?
                    .create()?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn abi_v2_exec_refer() {
        check_ruleset_support(
            ABI::V1,
            Some(ABI::V2),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::Execute)?
                    // AccessFs::Refer is not supported by ABI::V1 (best-effort).
                    .handle_access(AccessFs::Refer)?
                    .create()?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn abi_v2_refer_only() {
        // When no access is handled, do not try to create a ruleset without access.
        check_ruleset_support(
            ABI::V2,
            Some(ABI::V2),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::Refer)?
                    .create()?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn abi_v3_truncate() {
        check_ruleset_support(
            ABI::V2,
            Some(ABI::V3),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::Refer)?
                    .handle_access(AccessFs::Truncate)?
                    .create()?
                    .add_rule(PathBeneath::new(PathFd::new("/")?, AccessFs::Refer))?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn ruleset_created_try_clone() {
        check_ruleset_support(
            ABI::V1,
            Some(ABI::V1),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::Execute)?
                    .create()?
                    .add_rule(PathBeneath::new(PathFd::new("/")?, AccessFs::Execute))?
                    .try_clone()?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn abi_v4_tcp() {
        check_ruleset_support(
            ABI::V3,
            Some(ABI::V4),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessFs::Truncate)?
                    .handle_access(AccessNet::BindTcp | AccessNet::ConnectTcp)?
                    .create()?
                    .add_rule(NetPort::new(1, AccessNet::ConnectTcp))?
                    .restrict_self()?)
            },
            false,
        );
    }

    #[test]
    fn abi_v5_ioctl_dev() {
        check_ruleset_support(
            ABI::V4,
            Some(ABI::V5),
            move |ruleset: Ruleset| -> _ {
                Ok(ruleset
                    .handle_access(AccessNet::BindTcp)?
                    .handle_access(AccessFs::IoctlDev)?
                    .create()?
                    .add_rule(PathBeneath::new(PathFd::new("/")?, AccessFs::IoctlDev))?
                    .restrict_self()?)
            },
            false,
        );
    }
}
use anyhow::{Context, Result};
use dialoguer::{Input, Password};
use reqwest::blocking::Client;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
pub struct AuthResponse {
    pub token: String,
}

#[derive(Debug, Deserialize)]
pub struct Role {
    pub role_id: i32,
    pub role_name: String,
}

#[derive(Debug, Deserialize)]
pub struct Policy {
    pub default_ro: String,
    pub default_rw: String,
    pub tcp_bind: String,
    pub tcp_connect: String,
    pub allowed_ips: String,
    pub allowed_domains: String,
}

pub struct AuthSession {
    pub jwt: String,
    pub roles: Vec<Role>,
    pub client: Client,
    pub server_url: String,
}

impl AuthSession {
    pub fn login_and_fetch_roles() -> Result<Self> {
        let server_url = std::env::var("SERVER_URL")
            .unwrap_or_else(|_| "http://127.0.0.1:3005".into());

        let username: String = Input::new()
            .with_prompt("Username")
            .interact()
            .context("Failed to read username")?;

        let password: String = Password::new()
            .with_prompt("Password")
            .interact()
            .context("Failed to read password")?;

        let client = Client::new();

        // Step 1: POST /auth/login
        let res = client
            .post(format!("{}/auth/login", server_url))
            .json(&serde_json::json!({ "username": username, "password": password }))
            .send()
            .context("Failed to send login request")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!("Authentication failed: {}", res.status()));
        }

        let AuthResponse { token } = res.json().context("Failed to parse auth response")?;

        // Step 2: GET /auth/roles
        let res = client
            .get(format!("{}/auth/roles", server_url))
            .bearer_auth(&token)
            .send()
            .context("Failed to request user roles")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!("Role fetch failed: {}", res.status()));
        }

        let roles: Vec<Role> = res.json().context("Failed to parse roles")?;

        Ok(Self {
            jwt: token,
            roles,
            client,
            server_url,
        })
    }

    pub fn fetch_default_policy(&self, role_id: i32) -> Result<Policy> {
        let res = self
            .client
            .get(format!("{}/auth/ruleset?role_id={}", self.server_url, role_id))
            .bearer_auth(&self.jwt)
            .send()
            .context("Failed to request default policy")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!(
                "Default policy fetch failed: {}",
                res.status()
            ));
        }

        res.json::<Policy>()
            .context("Failed to parse default policy response")
    }

    pub fn fetch_app_policy(&self, role_id: i32, app_name: &str) -> Result<Policy> {
        let res = self
            .client
            .get(format!(
                "{}/auth/ruleset?role_id={}&app_name={}",
                self.server_url, role_id, app_name
            ))
            .bearer_auth(&self.jwt)
            .send()
            .context("Failed to request app policy")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!(
                "App policy fetch failed: {}",
                res.status()
            ));
        }

        res.json::<Policy>()
            .context("Failed to parse app policy response")
    }
}
use crate::compat::private::OptionCompatLevelMut;
use crate::{
    uapi, Access, AddRuleError, AddRulesError, CompatError, CompatLevel, CompatResult, CompatState,
    Compatible, HandleAccessError, HandleAccessesError, PrivateAccess, PrivateRule, Rule, Ruleset,
    RulesetCreated, TailoredCompatLevel, TryCompat, ABI,
};
use enumflags2::{bitflags, BitFlags};
use std::mem::zeroed;

/// Network access right.
///
/// Each variant of `AccessNet` is an [access right](https://www.kernel.org/doc/html/latest/userspace-api/landlock.html#access-rights)
/// for the network.
/// A set of access rights can be created with [`BitFlags<AccessNet>`](BitFlags).
///
/// # Example
///
/// ```
/// use landlock::{ABI, Access, AccessNet, BitFlags, make_bitflags};
///
/// let bind = AccessNet::BindTcp;
///
/// let bind_set: BitFlags<AccessNet> = bind.into();
///
/// let bind_connect = make_bitflags!(AccessNet::{BindTcp | ConnectTcp});
///
/// let net_v4 = AccessNet::from_all(ABI::V4);
///
/// assert_eq!(bind_connect, net_v4);
/// ```
///
/// # Warning
///
/// To avoid unknown restrictions **don't use `BitFlags::<AccessNet>::all()` nor `BitFlags::ALL`**,
/// but use a version you tested and vetted instead,
/// for instance [`AccessNet::from_all(ABI::V4)`](Access::from_all).
/// Direct use of **the [`BitFlags`] API is deprecated**.
/// See [`ABI`] for the rationale and help to test it.
#[bitflags]
#[repr(u64)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[non_exhaustive]
pub enum AccessNet {
    /// Bind to a TCP port.
    BindTcp = uapi::LANDLOCK_ACCESS_NET_BIND_TCP as u64,
    /// Connect to a TCP port.
    ConnectTcp = uapi::LANDLOCK_ACCESS_NET_CONNECT_TCP as u64,
}

/// # Warning
///
/// If `ABI <= ABI::V3`, `AccessNet::from_all()` returns an empty `BitFlags<AccessNet>`, which
/// makes `Ruleset::handle_access(AccessNet::from_all(ABI::V3))` return an error.
impl Access for AccessNet {
    fn from_all(abi: ABI) -> BitFlags<Self> {
        match abi {
            ABI::Unsupported | ABI::V1 | ABI::V2 | ABI::V3 => BitFlags::EMPTY,
            ABI::V4 | ABI::V5 => AccessNet::BindTcp | AccessNet::ConnectTcp,
        }
    }
}

impl PrivateAccess for AccessNet {
    fn ruleset_handle_access(
        ruleset: &mut Ruleset,
        access: BitFlags<Self>,
    ) -> Result<(), HandleAccessesError> {
        // We need to record the requested accesses for PrivateRule::check_consistency().
        ruleset.requested_handled_net |= access;
        ruleset.actual_handled_net |= match access
            .try_compat(
                ruleset.compat.abi(),
                ruleset.compat.level,
                &mut ruleset.compat.state,
            )
            .map_err(HandleAccessError::Compat)?
        {
            Some(a) => a,
            None => return Ok(()),
        };
        Ok(())
    }

    fn into_add_rules_error(error: AddRuleError<Self>) -> AddRulesError {
        AddRulesError::Net(error)
    }

    fn into_handle_accesses_error(error: HandleAccessError<Self>) -> HandleAccessesError {
        HandleAccessesError::Net(error)
    }
}

/// Landlock rule for a network port.
///
/// # Example
///
/// ```
/// use landlock::{AccessNet, NetPort};
///
/// fn bind_http() -> NetPort {
///     NetPort::new(80, AccessNet::BindTcp)
/// }
/// ```
#[cfg_attr(test, derive(Debug))]
pub struct NetPort {
    attr: uapi::landlock_net_port_attr,
    // Only 16-bit port make sense for now.
    port: u16,
    allowed_access: BitFlags<AccessNet>,
    compat_level: Option<CompatLevel>,
}

// If we need support for 32 or 64 ports, we'll add a new_32() or a new_64() method returning a
// Result with a potential overflow error.
impl NetPort {
    /// Creates a new TCP port rule.
    ///
    /// As defined by the Linux ABI, `port` with a value of `0` means that TCP bindings will be
    /// allowed for a port range defined by `/proc/sys/net/ipv4/ip_local_port_range`.
    pub fn new<A>(port: u16, access: A) -> Self
    where
        A: Into<BitFlags<AccessNet>>,
    {
        NetPort {
            // Invalid access-rights until as_ptr() is called.
            attr: unsafe { zeroed() },
            port,
            allowed_access: access.into(),
            compat_level: None,
        }
    }
}

impl Rule<AccessNet> for NetPort {}

impl PrivateRule<AccessNet> for NetPort {
    const TYPE_ID: uapi::landlock_rule_type = uapi::landlock_rule_type_LANDLOCK_RULE_NET_PORT;

    fn as_ptr(&mut self) -> *const libc::c_void {
        self.attr.port = self.port as u64;
        self.attr.allowed_access = self.allowed_access.bits();
        &self.attr as *const _ as _
    }

    fn check_consistency(&self, ruleset: &RulesetCreated) -> Result<(), AddRulesError> {
        // Checks that this rule doesn't contain a superset of the access-rights handled by the
        // ruleset.  This check is about requested access-rights but not actual access-rights.
        // Indeed, we want to get a deterministic behavior, i.e. not based on the running kernel
        // (which is handled by Ruleset and RulesetCreated).
        if ruleset.requested_handled_net.contains(self.allowed_access) {
            Ok(())
        } else {
            Err(AddRuleError::UnhandledAccess {
                access: self.allowed_access,
                incompatible: self.allowed_access & !ruleset.requested_handled_net,
            }
            .into())
        }
    }
}

#[test]
fn net_port_check_consistency() {
    use crate::*;

    let bind = AccessNet::BindTcp;
    let bind_connect = bind | AccessNet::ConnectTcp;

    assert!(matches!(
        Ruleset::from(ABI::Unsupported)
            .handle_access(bind)
            .unwrap()
            .create()
            .unwrap()
            .add_rule(NetPort::new(1, bind_connect))
            .unwrap_err(),
        RulesetError::AddRules(AddRulesError::Net(AddRuleError::UnhandledAccess { access, incompatible }))
            if access == bind_connect && incompatible == AccessNet::ConnectTcp
    ));
}

impl TryCompat<AccessNet> for NetPort {
    fn try_compat_children<L>(
        mut self,
        abi: ABI,
        parent_level: L,
        compat_state: &mut CompatState,
    ) -> Result<Option<Self>, CompatError<AccessNet>>
    where
        L: Into<CompatLevel>,
    {
        // Checks with our own compatibility level, if any.
        self.allowed_access = match self.allowed_access.try_compat(
            abi,
            self.tailored_compat_level(parent_level),
            compat_state,
        )? {
            Some(a) => a,
            None => return Ok(None),
        };
        Ok(Some(self))
    }

    fn try_compat_inner(
        &mut self,
        _abi: ABI,
    ) -> Result<CompatResult<AccessNet>, CompatError<AccessNet>> {
        Ok(CompatResult::Full)
    }
}

impl OptionCompatLevelMut for NetPort {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat_level
    }
}

impl OptionCompatLevelMut for &mut NetPort {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat_level
    }
}

impl Compatible for NetPort {}

impl Compatible for &mut NetPort {}
use anyhow::{Context, Result};
use reqwest::blocking::Client;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;
use std::env;
use std::path::PathBuf;

#[derive(Debug, Deserialize, Serialize)]
pub struct RuleSetRaw {
    #[serde(default)]
    pub default_ro: String,
    #[serde(default)]
    pub default_rw: String,
    #[serde(default)]
    pub tcp_bind: String,
    #[serde(default)]
    pub tcp_connect: String,
    #[serde(default)]
    pub allowed_ips: String,
    #[serde(default)]
    pub allowed_domains: String,
}

#[derive(Debug)]
pub struct RuleSet {
    pub ro_paths: HashSet<PathBuf>,
    pub rw_paths: HashSet<PathBuf>,
    pub tcp_bind: HashSet<u16>,
    pub tcp_connect: HashSet<u16>,
    pub allowed_ips: HashSet<String>,
    pub allowed_domains: HashSet<String>,
}

#[derive(Debug, Deserialize)]
pub struct LoginResponse {
    pub token: String,
}


#[derive(Debug, Serialize)]
struct LoginRequest {
    username: String,
    password: String,
}

#[derive(Debug, Deserialize)]
pub struct User {
    pub username: String,
    pub permissions: Vec<String>,
}

impl User {
    pub fn has_permission(&self, permission: &str) -> bool {
        self.permissions.iter().any(|p| p == permission)
    }
}
impl RuleSet {
    pub fn fetch_for_app(app: &str, token: &str) -> Result<Self> {
        let base_url = env::var("SERVER_URL")
            .unwrap_or_else(|_| "http://127.0.0.1:3005".to_string());
        let url = format!("{}/auth/ruleset?app_name={}", base_url, app);

        let client = Client::new();
        let res = client
            .get(&url)
            .bearer_auth(token)
            .send()
            .context("Failed to GET app ruleset")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!("Error fetching app ruleset: {}", res.status()));
        }

        let body = res.text().context("Failed to get response body")?;
        let json_value: serde_json::Value = serde_json::from_str(&body)
            .context("Failed to parse response as JSON")?;
        
        // Look for app-specific policy in app_policies array
        if let Some(app_policies) = json_value.get("app_policies") {
            if let Some(policies) = app_policies.as_array() {
                for policy in policies {
                    if let (Some(policy_app_name), Some(policy_data)) = (
                        policy.get("app_name").and_then(|v| v.as_str()),
                        policy.get("policy")
                    ) {
                        if policy_app_name == app {
                            println!("Found specific policy for app: {}", app);
                            return Self::parse_policy_object(policy_data);
                        }
                    }
                }
            }
        }
        
        // If no app-specific policy found, use the first default policy
        if let Some(default_policies) = json_value.get("default_policies") {
            if let Some(policies) = default_policies.as_array() {
                if !policies.is_empty() {
                    println!("Using default policy for app: {}", app);
                    return Self::parse_policy_object(&policies[0]);
                }
            }
        }
        
        // If no policy found at all, return empty ruleset
        println!("No policy found for app: {}, using empty policy", app);
        Ok(Self::default())
    }

    fn parse_policy_object(policy_obj: &serde_json::Value) -> Result<Self> {
        let mut ruleset = Self::default();
        
        if let Some(paths) = policy_obj.get("default_ro").and_then(|v| v.as_str()) {
            ruleset.ro_paths = split_paths(paths);
        }
        
        if let Some(paths) = policy_obj.get("default_rw").and_then(|v| v.as_str()) {
            ruleset.rw_paths = split_paths(paths);
        }
        
        if let Some(ports) = policy_obj.get("tcp_bind").and_then(|v| v.as_str()) {
            ruleset.tcp_bind = split_ports(ports);
        }
        
        if let Some(ports) = policy_obj.get("tcp_connect").and_then(|v| v.as_str()) {
            ruleset.tcp_connect = split_ports(ports);
        }
        
        if let Some(ips) = policy_obj.get("allowed_ips").and_then(|v| v.as_str()) {
            ruleset.allowed_ips = split_list(ips);
        }
        
        if let Some(domains) = policy_obj.get("allowed_domains").and_then(|v| v.as_str()) {
            ruleset.allowed_domains = split_list(domains);
        }
        
        Ok(ruleset)
    }

    pub fn upload(app: &str, ruleset_raw: &RuleSetRaw, token: &str) -> Result<()> {
        let base_url = env::var("SERVER_URL")
            .unwrap_or_else(|_| "http://127.0.0.1:3005".to_string());
        let url = format!("{}/auth/ruleset?app_name={}", base_url, app);

        let client = Client::new();
        let res = client
            .post(&url)
            .bearer_auth(token)
            .json(ruleset_raw)
            .send()
            .context("Failed to POST ruleset update")?;

        if !res.status().is_success() {
            return Err(anyhow::anyhow!("Error uploading ruleset: {}", res.status()));
        }

        Ok(())
    }

    pub fn login(username: &str, password: &str) -> Result<(String, User)> {
        let base_url = env::var("SERVER_URL")
            .unwrap_or_else(|_| "http://127.0.0.1:3005".to_string());
        let login_url = format!("{}/auth/login", base_url);
    
        let client = Client::new();
        let login_request = LoginRequest {
            username: username.to_string(),
            password: password.to_string(),
        };
    
        let res = client
            .post(&login_url)
            .json(&login_request)
            .send()
            .context("Failed to authenticate with server")?;
    
        if !res.status().is_success() {
            return Err(anyhow::anyhow!("Authentication failed: {}", res.status()));
        }
    
        let login_response: LoginResponse = res.json()
            .context("Failed to parse authentication response")?;
        
        // Now fetch user roles and permissions
        let roles_url = format!("{}/auth/roles", base_url);
        let roles_res = client
            .get(&roles_url)
            .bearer_auth(&login_response.token)
            .send()
            .context("Failed to fetch user roles")?;
            
        if !roles_res.status().is_success() {
            return Err(anyhow::anyhow!("Failed to get user roles: {}", roles_res.status()));
        }
        
        let roles_data: serde_json::Value = roles_res.json()
            .context("Failed to parse roles response")?;
        
        let permissions = if let Some(perms) = roles_data.get("permissions").and_then(|p| p.as_array()) {
            perms.iter()
                .filter_map(|v| v.as_str().map(String::from))
                .collect()
        } else {
            Vec::new()
        };
        
        let user = User {
            username: username.to_string(),
            permissions,
        };
    
        Ok((login_response.token, user))
    }
    
}

impl Default for RuleSet {
    fn default() -> Self {
        Self {
            ro_paths: HashSet::new(),
            rw_paths: HashSet::new(),
            tcp_bind: HashSet::new(),
            tcp_connect: HashSet::new(),
            allowed_ips: HashSet::new(),
            allowed_domains: HashSet::new(),
        }
    }
}

// Helpers
fn split_paths(s: &str) -> HashSet<PathBuf> {
    s.split(':').filter(|s| !s.is_empty()).map(PathBuf::from).collect()
}

fn split_ports(s: &str) -> HashSet<u16> {
    s.split(':').filter_map(|s| s.parse().ok()).collect()
}

fn split_list(s: &str) -> HashSet<String> {
    s.split(':').filter(|s| !s.is_empty()).map(str::to_string).collect()
}

pub fn log_denial_event(
    app_name: &str,
    denied_path: &str,
    operation: &str,
    token: &str,
) -> Result<()> {
    let base_url = env::var("SERVER_URL")
        .unwrap_or_else(|_| "http://127.0.0.1:3005".to_string());
    let url = format!("{}/events/log", base_url); //  fixed route

    let hostname = hostname::get()
        .unwrap_or_default()
        .to_string_lossy()
        .to_string();

    let client = Client::new();
    let event = serde_json::json!({
        "hostname": hostname,
        "app_name": app_name,
        "denied_path": denied_path,
        "operation": operation,
        "result": "denied",
        "remote_ip": "127.0.0.1",
        "domain": "localhost"             
    });

    let res = client
        .post(&url)
        .bearer_auth(token)
        .json(&event)
        .send()
        .context("Failed to send denial event")?;

    if !res.status().is_success() {
        eprintln!("Warning: Failed to log denial event: {}", res.status());
    }

    Ok(())
}
use crate::compat::private::OptionCompatLevelMut;
use crate::{
    uapi, Access, AccessFs, AccessNet, AddRuleError, AddRulesError, BitFlags, CompatLevel,
    CompatState, Compatibility, Compatible, CreateRulesetError, RestrictSelfError, RulesetError,
    TryCompat,
};
use libc::close;
use std::io::Error;
use std::mem::size_of_val;
use std::os::unix::io::RawFd;

#[cfg(test)]
use crate::*;

// Public interface without methods and which is impossible to implement outside this crate.
pub trait Rule<T>: PrivateRule<T>
where
    T: Access,
{
}

// PrivateRule is not public outside this crate.
pub trait PrivateRule<T>
where
    Self: TryCompat<T> + Compatible,
    T: Access,
{
    const TYPE_ID: uapi::landlock_rule_type;

    /// Returns a raw pointer to the rule's inner attribute.
    ///
    /// The caller must ensure that the rule outlives the pointer this function returns, or else it
    /// will end up pointing to garbage.
    fn as_ptr(&mut self) -> *const libc::c_void;

    fn check_consistency(&self, ruleset: &RulesetCreated) -> Result<(), AddRulesError>;
}

/// Enforcement status of a ruleset.
#[derive(Debug, PartialEq, Eq)]
pub enum RulesetStatus {
    /// All requested restrictions are enforced.
    FullyEnforced,
    /// Some requested restrictions are enforced,
    /// following a best-effort approach.
    PartiallyEnforced,
    /// The running system doesn't support Landlock
    /// or a subset of the requested Landlock features.
    NotEnforced,
}

impl From<CompatState> for RulesetStatus {
    fn from(state: CompatState) -> Self {
        match state {
            CompatState::Init | CompatState::No | CompatState::Dummy => RulesetStatus::NotEnforced,
            CompatState::Full => RulesetStatus::FullyEnforced,
            CompatState::Partial => RulesetStatus::PartiallyEnforced,
        }
    }
}

// The Debug, PartialEq and Eq implementations are useful for crate users to debug and check the
// result of a Landlock ruleset enforcement.
/// Status of a [`RulesetCreated`]
/// after calling [`restrict_self()`](RulesetCreated::restrict_self).
#[derive(Debug, PartialEq, Eq)]
#[non_exhaustive]
pub struct RestrictionStatus {
    /// Status of the Landlock ruleset enforcement.
    pub ruleset: RulesetStatus,
    /// Status of `prctl(2)`'s `PR_SET_NO_NEW_PRIVS` enforcement.
    pub no_new_privs: bool,
}

fn prctl_set_no_new_privs() -> Result<(), Error> {
    match unsafe { libc::prctl(libc::PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) } {
        0 => Ok(()),
        _ => Err(Error::last_os_error()),
    }
}

fn support_no_new_privs() -> bool {
    // Only Linux < 3.5 or kernel with seccomp filters should return an error.
    matches!(
        unsafe { libc::prctl(libc::PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) },
        0 | 1
    )
}

/// Landlock ruleset builder.
///
/// `Ruleset` enables to create a Landlock ruleset in a flexible way
/// following the builder pattern.
/// Most build steps return a [`Result`] with [`RulesetError`].
///
/// You should probably not create more than one ruleset per application.
/// Creating multiple rulesets is only useful when gradually restricting an application
/// (e.g., a first set of generic restrictions before reading any file,
/// then a second set of tailored restrictions after reading the configuration).
///
/// # Simple example
///
/// Simple helper handling only Landlock-related errors.
///
/// ```
/// use landlock::{
///     Access, AccessFs, PathBeneath, PathFd, RestrictionStatus, Ruleset, RulesetAttr,
///     RulesetCreatedAttr, RulesetError, ABI,
/// };
/// use std::os::unix::io::AsFd;
///
/// fn restrict_fd<T>(hierarchy: T) -> Result<RestrictionStatus, RulesetError>
/// where
///     T: AsFd,
/// {
///     // The Landlock ABI should be incremented (and tested) regularly.
///     let abi = ABI::V1;
///     let access_all = AccessFs::from_all(abi);
///     let access_read = AccessFs::from_read(abi);
///     Ok(Ruleset::default()
///         .handle_access(access_all)?
///         .create()?
///         .add_rule(PathBeneath::new(hierarchy, access_read))?
///         .restrict_self()?)
/// }
///
/// let fd = PathFd::new("/home").expect("failed to open /home");
/// let status = restrict_fd(fd).expect("failed to build the ruleset");
/// ```
///
/// # Generic example
///
/// More generic helper handling a set of file hierarchies
/// and multiple types of error (i.e. [`RulesetError`](crate::RulesetError)
/// and [`PathFdError`](crate::PathFdError).
///
/// ```
/// use landlock::{
///     Access, AccessFs, PathBeneath, PathFd, PathFdError, RestrictionStatus, Ruleset,
///     RulesetAttr, RulesetCreatedAttr, RulesetError, ABI,
/// };
/// use thiserror::Error;
///
/// #[derive(Debug, Error)]
/// enum MyRestrictError {
///     #[error(transparent)]
///     Ruleset(#[from] RulesetError),
///     #[error(transparent)]
///     AddRule(#[from] PathFdError),
/// }
///
/// fn restrict_paths(hierarchies: &[&str]) -> Result<RestrictionStatus, MyRestrictError> {
///     // The Landlock ABI should be incremented (and tested) regularly.
///     let abi = ABI::V1;
///     let access_all = AccessFs::from_all(abi);
///     let access_read = AccessFs::from_read(abi);
///     Ok(Ruleset::default()
///         .handle_access(access_all)?
///         .create()?
///         .add_rules(
///             hierarchies
///                 .iter()
///                 .map::<Result<_, MyRestrictError>, _>(|p| {
///                     Ok(PathBeneath::new(PathFd::new(p)?, access_read))
///                 }),
///         )?
///         .restrict_self()?)
/// }
///
/// let status = restrict_paths(&["/usr", "/home"]).expect("failed to build the ruleset");
/// ```
#[cfg_attr(test, derive(Debug))]
pub struct Ruleset {
    pub(crate) requested_handled_fs: BitFlags<AccessFs>,
    pub(crate) requested_handled_net: BitFlags<AccessNet>,
    pub(crate) actual_handled_fs: BitFlags<AccessFs>,
    pub(crate) actual_handled_net: BitFlags<AccessNet>,
    pub(crate) compat: Compatibility,
}

impl From<Compatibility> for Ruleset {
    fn from(compat: Compatibility) -> Self {
        Ruleset {
            // Non-working default handled FS accesses to force users to set them explicitely.
            requested_handled_fs: Default::default(),
            requested_handled_net: Default::default(),
            actual_handled_fs: Default::default(),
            actual_handled_net: Default::default(),
            compat,
        }
    }
}

#[cfg(test)]
impl From<ABI> for Ruleset {
    fn from(abi: ABI) -> Self {
        Ruleset::from(Compatibility::from(abi))
    }
}

#[test]
fn ruleset_add_rule_iter() {
    assert!(matches!(
        Ruleset::from(ABI::Unsupported)
            .handle_access(AccessFs::Execute)
            .unwrap()
            .create()
            .unwrap()
            .add_rule(PathBeneath::new(
                PathFd::new("/").unwrap(),
                AccessFs::ReadFile
            ))
            .unwrap_err(),
        RulesetError::AddRules(AddRulesError::Fs(AddRuleError::UnhandledAccess { .. }))
    ));
}

impl Default for Ruleset {
    /// Returns a new `Ruleset`.
    /// This call automatically probes the running kernel to know if it supports Landlock.
    ///
    /// To be able to successfully call [`create()`](Ruleset::create),
    /// it is required to set the handled accesses with
    /// [`handle_access()`](Ruleset::handle_access).
    fn default() -> Self {
        // The API should be future-proof: one Rust program or library should have the same
        // behavior if built with an old or a newer crate (e.g. with an extended ruleset_attr
        // enum).  It should then not be possible to give an "all-possible-handled-accesses" to the
        // Ruleset builder because this value would be relative to the running kernel.
        Compatibility::new().into()
    }
}

impl Ruleset {
    #[allow(clippy::new_without_default)]
    #[deprecated(note = "Use Ruleset::default() instead")]
    pub fn new() -> Self {
        Ruleset::default()
    }

    /// Attempts to create a real Landlock ruleset (if supported by the running kernel).
    /// The returned [`RulesetCreated`] is also a builder.
    ///
    /// On error, returns a wrapped [`CreateRulesetError`].
    pub fn create(mut self) -> Result<RulesetCreated, RulesetError> {
        let body = || -> Result<RulesetCreated, CreateRulesetError> {
            match self.compat.state {
                CompatState::Init => {
                    // Checks that there is at least one requested access (e.g.
                    // requested_handled_fs): one call to handle_access().
                    Err(CreateRulesetError::MissingHandledAccess)
                }
                CompatState::No | CompatState::Dummy => {
                    // There is at least one requested access.
                    #[cfg(test)]
                    assert!(
                        !self.requested_handled_fs.is_empty()
                            || !self.requested_handled_net.is_empty()
                    );

                    // CompatState::No should be handled as CompatState::Dummy because it is not
                    // possible to create an actual ruleset.
                    self.compat.update(CompatState::Dummy);
                    match self.compat.level.into() {
                        CompatLevel::HardRequirement => {
                            Err(CreateRulesetError::MissingHandledAccess)
                        }
                        _ => Ok(RulesetCreated::new(self, -1)),
                    }
                }
                CompatState::Full | CompatState::Partial => {
                    // There is at least one actual handled access.
                    #[cfg(test)]
                    assert!(
                        !self.actual_handled_fs.is_empty() || !self.actual_handled_net.is_empty()
                    );

                    let attr = uapi::landlock_ruleset_attr {
                        handled_access_fs: self.actual_handled_fs.bits(),
                        handled_access_net: self.actual_handled_net.bits(),
                    };
                    match unsafe { uapi::landlock_create_ruleset(&attr, size_of_val(&attr), 0) } {
                        fd if fd >= 0 => Ok(RulesetCreated::new(self, fd)),
                        _ => Err(CreateRulesetError::CreateRulesetCall {
                            source: Error::last_os_error(),
                        }),
                    }
                }
            }
        };
        Ok(body()?)
    }
}

impl OptionCompatLevelMut for Ruleset {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat.level
    }
}

impl OptionCompatLevelMut for &mut Ruleset {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat.level
    }
}

impl Compatible for Ruleset {}

impl Compatible for &mut Ruleset {}

impl AsMut<Ruleset> for Ruleset {
    fn as_mut(&mut self) -> &mut Ruleset {
        self
    }
}

// Tests unambiguous type.
#[test]
fn ruleset_as_mut() {
    let mut ruleset = Ruleset::from(ABI::Unsupported);
    let _ = ruleset.as_mut();

    let mut ruleset_created = Ruleset::from(ABI::Unsupported)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .create()
        .unwrap();
    let _ = ruleset_created.as_mut();
}

pub trait RulesetAttr: Sized + AsMut<Ruleset> + Compatible {
    /// Attempts to add a set of access rights that will be supported by this ruleset.
    /// By default, all actions requiring these access rights will be denied.
    /// Consecutive calls to `handle_access()` will be interpreted as logical ORs
    /// with the previous handled accesses.
    ///
    /// On error, returns a wrapped [`HandleAccessesError`](crate::HandleAccessesError).
    /// E.g., `RulesetError::HandleAccesses(HandleAccessesError::Fs(HandleAccessError<AccessFs>))`
    fn handle_access<T, U>(mut self, access: T) -> Result<Self, RulesetError>
    where
        T: Into<BitFlags<U>>,
        U: Access,
    {
        U::ruleset_handle_access(self.as_mut(), access.into())?;
        Ok(self)
    }
}

impl RulesetAttr for Ruleset {}

impl RulesetAttr for &mut Ruleset {}

#[test]
fn ruleset_attr() {
    let mut ruleset = Ruleset::from(ABI::Unsupported);
    let ruleset_ref = &mut ruleset;

    // Can pass this reference to prepare the ruleset...
    ruleset_ref
        .set_compatibility(CompatLevel::BestEffort)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .handle_access(AccessFs::ReadFile)
        .unwrap();

    // ...and finally create the ruleset (thanks to non-lexical lifetimes).
    ruleset
        .set_compatibility(CompatLevel::BestEffort)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .handle_access(AccessFs::WriteFile)
        .unwrap()
        .create()
        .unwrap();
}

#[test]
fn ruleset_created_handle_access_fs() {
    // Tests AccessFs::ruleset_handle_access()
    let ruleset = Ruleset::from(ABI::V1)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .handle_access(AccessFs::ReadDir)
        .unwrap();
    let access = make_bitflags!(AccessFs::{Execute | ReadDir});
    assert_eq!(ruleset.requested_handled_fs, access);
    assert_eq!(ruleset.actual_handled_fs, access);

    // Tests that only the required handled accesses are reported as incompatible:
    // access should not contains AccessFs::Execute.
    assert!(matches!(Ruleset::from(ABI::Unsupported)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .set_compatibility(CompatLevel::HardRequirement)
        .handle_access(AccessFs::ReadDir)
        .unwrap_err(),
        RulesetError::HandleAccesses(HandleAccessesError::Fs(HandleAccessError::Compat(
            CompatError::Access(AccessError::Incompatible { access })
        ))) if access == AccessFs::ReadDir
    ));
}

#[test]
fn ruleset_created_handle_access_net_tcp() {
    let access = make_bitflags!(AccessNet::{BindTcp | ConnectTcp});

    // Tests AccessNet::ruleset_handle_access() with ABI that doesn't support TCP rights.
    let ruleset = Ruleset::from(ABI::V3).handle_access(access).unwrap();
    assert_eq!(ruleset.requested_handled_net, access);
    assert_eq!(ruleset.actual_handled_net, BitFlags::<AccessNet>::EMPTY);

    // Tests AccessNet::ruleset_handle_access() with ABI that supports TCP rights.
    let ruleset = Ruleset::from(ABI::V4).handle_access(access).unwrap();
    assert_eq!(ruleset.requested_handled_net, access);
    assert_eq!(ruleset.actual_handled_net, access);

    // Tests that only the required handled accesses are reported as incompatible:
    // access should not contains AccessNet::BindTcp.
    assert!(matches!(Ruleset::from(ABI::Unsupported)
        .handle_access(AccessNet::BindTcp)
        .unwrap()
        .set_compatibility(CompatLevel::HardRequirement)
        .handle_access(AccessNet::ConnectTcp)
        .unwrap_err(),
        RulesetError::HandleAccesses(HandleAccessesError::Net(HandleAccessError::Compat(
            CompatError::Access(AccessError::Incompatible { access })
        ))) if access == AccessNet::ConnectTcp
    ));
}

impl OptionCompatLevelMut for RulesetCreated {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat.level
    }
}

impl OptionCompatLevelMut for &mut RulesetCreated {
    fn as_option_compat_level_mut(&mut self) -> &mut Option<CompatLevel> {
        &mut self.compat.level
    }
}

impl Compatible for RulesetCreated {}

impl Compatible for &mut RulesetCreated {}

pub trait RulesetCreatedAttr: Sized + AsMut<RulesetCreated> + Compatible {
    /// Attempts to add a new rule to the ruleset.
    ///
    /// On error, returns a wrapped [`AddRulesError`].
    fn add_rule<T, U>(mut self, rule: T) -> Result<Self, RulesetError>
    where
        T: Rule<U>,
        U: Access,
    {
        let body = || -> Result<Self, AddRulesError> {
            let self_ref = self.as_mut();
            rule.check_consistency(self_ref)?;
            let mut compat_rule = match rule
                .try_compat(
                    self_ref.compat.abi(),
                    self_ref.compat.level,
                    &mut self_ref.compat.state,
                )
                .map_err(AddRuleError::Compat)?
            {
                Some(r) => r,
                None => return Ok(self),
            };
            match self_ref.compat.state {
                CompatState::Init | CompatState::No | CompatState::Dummy => Ok(self),
                CompatState::Full | CompatState::Partial => match unsafe {
                    uapi::landlock_add_rule(self_ref.fd, T::TYPE_ID, compat_rule.as_ptr(), 0)
                } {
                    0 => Ok(self),
                    _ => Err(AddRuleError::<U>::AddRuleCall {
                        source: Error::last_os_error(),
                    }
                    .into()),
                },
            }
        };
        Ok(body()?)
    }

    /// Attempts to add a set of new rules to the ruleset.
    ///
    /// On error, returns a (double) wrapped [`AddRulesError`].
    ///
    /// # Example
    ///
    /// Create a custom iterator to read paths from environment variable.
    ///
    /// ```
    /// use landlock::{
    ///     Access, AccessFs, BitFlags, PathBeneath, PathFd, PathFdError, RestrictionStatus, Ruleset,
    ///     RulesetAttr, RulesetCreatedAttr, RulesetError, ABI,
    /// };
    /// use std::env;
    /// use std::ffi::OsStr;
    /// use std::os::unix::ffi::{OsStrExt, OsStringExt};
    /// use thiserror::Error;
    ///
    /// #[derive(Debug, Error)]
    /// enum PathEnvError<'a> {
    ///     #[error(transparent)]
    ///     Ruleset(#[from] RulesetError),
    ///     #[error(transparent)]
    ///     AddRuleIter(#[from] PathFdError),
    ///     #[error("missing environment variable {0}")]
    ///     MissingVar(&'a str),
    /// }
    ///
    /// struct PathEnv {
    ///     paths: Vec<u8>,
    ///     access: BitFlags<AccessFs>,
    /// }
    ///
    /// impl PathEnv {
    ///     // env_var is the name of an environment variable
    ///     // containing paths requested to be allowed.
    ///     // Paths are separated with ":", e.g. "/bin:/lib:/usr:/proc".
    ///     // In case an empty string is provided,
    ///     // no restrictions are applied.
    ///     // `access` is the set of access rights allowed for each of the parsed paths.
    ///     fn new<'a>(
    ///         env_var: &'a str, access: BitFlags<AccessFs>
    ///     ) -> Result<Self, PathEnvError<'a>> {
    ///         Ok(Self {
    ///             paths: env::var_os(env_var)
    ///                 .ok_or(PathEnvError::MissingVar(env_var))?
    ///                 .into_vec(),
    ///             access,
    ///         })
    ///     }
    ///
    ///     fn iter(
    ///         &self,
    ///     ) -> impl Iterator<Item = Result<PathBeneath<PathFd>, PathEnvError<'static>>> + '_ {
    ///         let is_empty = self.paths.is_empty();
    ///         self.paths
    ///             .split(|b| *b == b':')
    ///             // Skips the first empty element from of an empty string.
    ///             .skip_while(move |_| is_empty)
    ///             .map(OsStr::from_bytes)
    ///             .map(move |path|
    ///                 Ok(PathBeneath::new(PathFd::new(path)?, self.access)))
    ///     }
    /// }
    ///
    /// fn restrict_env() -> Result<RestrictionStatus, PathEnvError<'static>> {
    ///     Ok(Ruleset::default()
    ///         .handle_access(AccessFs::from_all(ABI::V1))?
    ///         .create()?
    ///         // In the shell: export EXECUTABLE_PATH="/usr:/bin:/sbin"
    ///         .add_rules(PathEnv::new("EXECUTABLE_PATH", AccessFs::Execute.into())?.iter())?
    ///         .restrict_self()?)
    /// }
    /// ```
    fn add_rules<I, T, U, E>(mut self, rules: I) -> Result<Self, E>
    where
        I: IntoIterator<Item = Result<T, E>>,
        T: Rule<U>,
        U: Access,
        E: From<RulesetError>,
    {
        for rule in rules {
            self = self.add_rule(rule?)?;
        }
        Ok(self)
    }

    /// Configures the ruleset to call `prctl(2)` with the `PR_SET_NO_NEW_PRIVS` command
    /// in [`restrict_self()`](RulesetCreated::restrict_self).
    ///
    /// This `prctl(2)` call is never ignored, even if an error was encountered on a [`Ruleset`] or
    /// [`RulesetCreated`] method call while [`CompatLevel::SoftRequirement`] was set.
    fn set_no_new_privs(mut self, no_new_privs: bool) -> Self {
        <Self as AsMut<RulesetCreated>>::as_mut(&mut self).no_new_privs = no_new_privs;
        self
    }
}

/// Ruleset created with [`Ruleset::create()`].
#[cfg_attr(test, derive(Debug))]
pub struct RulesetCreated {
    fd: RawFd,
    no_new_privs: bool,
    pub(crate) requested_handled_fs: BitFlags<AccessFs>,
    pub(crate) requested_handled_net: BitFlags<AccessNet>,
    compat: Compatibility,
}

impl RulesetCreated {
    pub(crate) fn new(ruleset: Ruleset, fd: RawFd) -> Self {
        // The compatibility state is initialized by Ruleset::create().
        #[cfg(test)]
        assert!(!matches!(ruleset.compat.state, CompatState::Init));

        RulesetCreated {
            fd,
            no_new_privs: true,
            requested_handled_fs: ruleset.requested_handled_fs,
            requested_handled_net: ruleset.requested_handled_net,
            compat: ruleset.compat,
        }
    }

    /// Attempts to restrict the calling thread with the ruleset
    /// according to the best-effort configuration
    /// (see [`RulesetCreated::set_compatibility()`] and [`CompatLevel::BestEffort`]).
    /// Call `prctl(2)` with the `PR_SET_NO_NEW_PRIVS`
    /// according to the ruleset configuration.
    ///
    /// On error, returns a wrapped [`RestrictSelfError`].
    pub fn restrict_self(mut self) -> Result<RestrictionStatus, RulesetError> {
        let mut body = || -> Result<RestrictionStatus, RestrictSelfError> {
            // Enforce no_new_privs even if something failed with SoftRequirement. The rationale is
            // that no_new_privs should not be an issue on its own if it is not explicitly
            // deactivated.
            let enforced_nnp = if self.no_new_privs {
                if let Err(e) = prctl_set_no_new_privs() {
                    match self.compat.level.into() {
                        CompatLevel::BestEffort => {}
                        CompatLevel::SoftRequirement => {
                            self.compat.update(CompatState::Dummy);
                        }
                        CompatLevel::HardRequirement => {
                            return Err(RestrictSelfError::SetNoNewPrivsCall { source: e });
                        }
                    }
                    // To get a consistent behavior, calls this prctl whether or not
                    // Landlock is supported by the running kernel.
                    let support_nnp = support_no_new_privs();
                    match self.compat.state {
                        // It should not be an error for kernel (older than 3.5) not supporting
                        // no_new_privs.
                        CompatState::Init | CompatState::No | CompatState::Dummy => {
                            if support_nnp {
                                // The kernel seems to be between 3.5 (included) and 5.13 (excluded),
                                // or Landlock is not enabled; no_new_privs should be supported anyway.
                                return Err(RestrictSelfError::SetNoNewPrivsCall { source: e });
                            }
                        }
                        // A kernel supporting Landlock should also support no_new_privs (unless
                        // filtered by seccomp).
                        CompatState::Full | CompatState::Partial => {
                            return Err(RestrictSelfError::SetNoNewPrivsCall { source: e })
                        }
                    }
                    false
                } else {
                    true
                }
            } else {
                false
            };

            match self.compat.state {
                CompatState::Init | CompatState::No | CompatState::Dummy => Ok(RestrictionStatus {
                    ruleset: self.compat.state.into(),
                    no_new_privs: enforced_nnp,
                }),
                CompatState::Full | CompatState::Partial => {
                    match unsafe { uapi::landlock_restrict_self(self.fd, 0) } {
                        0 => {
                            self.compat.update(CompatState::Full);
                            Ok(RestrictionStatus {
                                ruleset: self.compat.state.into(),
                                no_new_privs: enforced_nnp,
                            })
                        }
                        // TODO: match specific Landlock restrict self errors
                        _ => Err(RestrictSelfError::RestrictSelfCall {
                            source: Error::last_os_error(),
                        }),
                    }
                }
            }
        };
        Ok(body()?)
    }

    /// Creates a new `RulesetCreated` instance by duplicating the underlying file descriptor.
    /// Rule modification will affect both `RulesetCreated` instances simultaneously.
    ///
    /// On error, returns [`std::io::Error`].
    pub fn try_clone(&self) -> std::io::Result<Self> {
        Ok(RulesetCreated {
            fd: match self.fd {
                -1 => -1,
                self_fd => match unsafe { libc::fcntl(self_fd, libc::F_DUPFD_CLOEXEC, 0) } {
                    dup_fd if dup_fd >= 0 => dup_fd,
                    _ => return Err(Error::last_os_error()),
                },
            },
            no_new_privs: self.no_new_privs,
            requested_handled_fs: self.requested_handled_fs,
            requested_handled_net: self.requested_handled_net,
            compat: self.compat,
        })
    }
}

impl Drop for RulesetCreated {
    fn drop(&mut self) {
        if self.fd >= 0 {
            unsafe { close(self.fd) };
        }
    }
}

impl AsMut<RulesetCreated> for RulesetCreated {
    fn as_mut(&mut self) -> &mut RulesetCreated {
        self
    }
}

impl RulesetCreatedAttr for RulesetCreated {}

impl RulesetCreatedAttr for &mut RulesetCreated {}

#[test]
fn ruleset_created_attr() {
    let mut ruleset_created = Ruleset::from(ABI::Unsupported)
        .handle_access(AccessFs::Execute)
        .unwrap()
        .create()
        .unwrap();
    let ruleset_created_ref = &mut ruleset_created;

    // Can pass this reference to populate the ruleset...
    ruleset_created_ref
        .set_compatibility(CompatLevel::BestEffort)
        .add_rule(PathBeneath::new(
            PathFd::new("/usr").unwrap(),
            AccessFs::Execute,
        ))
        .unwrap()
        .add_rule(PathBeneath::new(
            PathFd::new("/etc").unwrap(),
            AccessFs::Execute,
        ))
        .unwrap();

    // ...and finally restrict with the last rules (thanks to non-lexical lifetimes).
    assert_eq!(
        ruleset_created
            .set_compatibility(CompatLevel::BestEffort)
            .add_rule(PathBeneath::new(
                PathFd::new("/tmp").unwrap(),
                AccessFs::Execute,
            ))
            .unwrap()
            .add_rule(PathBeneath::new(
                PathFd::new("/var").unwrap(),
                AccessFs::Execute,
            ))
            .unwrap()
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            no_new_privs: true,
        }
    );
}

#[test]
fn ruleset_compat_dummy() {
    for level in [CompatLevel::BestEffort, CompatLevel::SoftRequirement] {
        println!("level: {:?}", level);

        // ABI:Unsupported does not support AccessFs::Execute.
        let ruleset = Ruleset::from(ABI::Unsupported);
        assert_eq!(ruleset.compat.state, CompatState::Init);

        let ruleset = ruleset.set_compatibility(level);
        assert_eq!(ruleset.compat.state, CompatState::Init);

        let ruleset = ruleset.handle_access(AccessFs::Execute).unwrap();
        assert_eq!(
            ruleset.compat.state,
            match level {
                CompatLevel::BestEffort => CompatState::No,
                CompatLevel::SoftRequirement => CompatState::Dummy,
                _ => unreachable!(),
            }
        );

        let ruleset_created = ruleset.create().unwrap();
        // Because the compatibility state was either No or Dummy, calling create() updates it to
        // Dummy.
        assert_eq!(ruleset_created.compat.state, CompatState::Dummy);

        let ruleset_created = ruleset_created
            .add_rule(PathBeneath::new(
                PathFd::new("/usr").unwrap(),
                AccessFs::Execute,
            ))
            .unwrap();
        assert_eq!(ruleset_created.compat.state, CompatState::Dummy);
    }
}

#[test]
fn ruleset_compat_partial() {
    // CompatLevel::BestEffort
    let ruleset = Ruleset::from(ABI::V1);
    assert_eq!(ruleset.compat.state, CompatState::Init);

    // ABI::V1 does not support AccessFs::Refer.
    let ruleset = ruleset.handle_access(AccessFs::Refer).unwrap();
    assert_eq!(ruleset.compat.state, CompatState::No);

    let ruleset = ruleset.handle_access(AccessFs::Execute).unwrap();
    assert_eq!(ruleset.compat.state, CompatState::Partial);

    // Requesting to handle another unsupported handled access does not change anything.
    let ruleset = ruleset.handle_access(AccessFs::Refer).unwrap();
    assert_eq!(ruleset.compat.state, CompatState::Partial);
}

#[test]
fn ruleset_unsupported() {
    assert_eq!(
        Ruleset::from(ABI::Unsupported)
            // BestEffort for Ruleset.
            .handle_access(AccessFs::Execute)
            .unwrap()
            .create()
            .unwrap()
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            // With BestEffort, no_new_privs is still enabled.
            no_new_privs: true,
        }
    );

    assert_eq!(
        Ruleset::from(ABI::Unsupported)
            // SoftRequirement for Ruleset.
            .set_compatibility(CompatLevel::SoftRequirement)
            .handle_access(AccessFs::Execute)
            .unwrap()
            .create()
            .unwrap()
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            // With SoftRequirement, no_new_privs is still enabled.
            no_new_privs: true,
        }
    );

    matches!(
        Ruleset::from(ABI::Unsupported)
            // HardRequirement for Ruleset.
            .set_compatibility(CompatLevel::HardRequirement)
            .handle_access(AccessFs::Execute)
            .unwrap_err(),
        RulesetError::CreateRuleset(CreateRulesetError::MissingHandledAccess)
    );

    assert_eq!(
        Ruleset::from(ABI::Unsupported)
            .handle_access(AccessFs::Execute)
            .unwrap()
            .create()
            .unwrap()
            // SoftRequirement for RulesetCreated without any rule.
            .set_compatibility(CompatLevel::SoftRequirement)
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            // With SoftRequirement, no_new_privs is untouched if there is no error (e.g. no rule).
            no_new_privs: true,
        }
    );

    // Don't explicitly call create() on a CI that doesn't support Landlock.
    if compat::can_emulate(ABI::V1, ABI::V1, Some(ABI::V2)) {
        assert_eq!(
            Ruleset::from(ABI::V1)
                .handle_access(make_bitflags!(AccessFs::{Execute | Refer}))
                .unwrap()
                .create()
                .unwrap()
                // SoftRequirement for RulesetCreated with a rule.
                .set_compatibility(CompatLevel::SoftRequirement)
                .add_rule(PathBeneath::new(PathFd::new("/").unwrap(), AccessFs::Refer))
                .unwrap()
                .restrict_self()
                .unwrap(),
            RestrictionStatus {
                ruleset: RulesetStatus::NotEnforced,
                // With SoftRequirement, no_new_privs is still enabled, even if there is an error
                // (e.g. unsupported access right).
                no_new_privs: true,
            }
        );
    }

    assert_eq!(
        Ruleset::from(ABI::Unsupported)
            .handle_access(AccessFs::Execute)
            .unwrap()
            .create()
            .unwrap()
            .set_no_new_privs(false)
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            no_new_privs: false,
        }
    );

    assert!(matches!(
        Ruleset::from(ABI::Unsupported)
            // Empty access-rights
            .handle_access(AccessFs::from_all(ABI::Unsupported))
            .unwrap_err(),
        RulesetError::HandleAccesses(HandleAccessesError::Fs(HandleAccessError::Compat(
            CompatError::Access(AccessError::Empty)
        )))
    ));

    assert!(matches!(
        Ruleset::from(ABI::Unsupported)
            // No handle_access() call.
            .create()
            .unwrap_err(),
        RulesetError::CreateRuleset(CreateRulesetError::MissingHandledAccess)
    ));

    assert!(matches!(
        Ruleset::from(ABI::V1)
            // Empty access-rights
            .handle_access(AccessFs::from_all(ABI::Unsupported))
            .unwrap_err(),
        RulesetError::HandleAccesses(HandleAccessesError::Fs(HandleAccessError::Compat(
            CompatError::Access(AccessError::Empty)
        )))
    ));

    // Tests inconsistency between the ruleset handled access-rights and the rule access-rights.
    for handled_access in &[
        make_bitflags!(AccessFs::{Execute | WriteFile}),
        AccessFs::Execute.into(),
    ] {
        let ruleset = Ruleset::from(ABI::V1)
            .handle_access(*handled_access)
            .unwrap();
        // Fakes a call to create() to test without involving the kernel (i.e. no
        // landlock_ruleset_create() call).
        let ruleset_created = RulesetCreated::new(ruleset, -1);
        assert!(matches!(
            ruleset_created
                .add_rule(PathBeneath::new(
                    PathFd::new("/").unwrap(),
                    AccessFs::ReadFile
                ))
                .unwrap_err(),
            RulesetError::AddRules(AddRulesError::Fs(AddRuleError::UnhandledAccess { .. }))
        ));
    }
}

#[test]
fn ignore_abi_v2_with_abi_v1() {
    // We don't need kernel/CI support for Landlock because no related syscalls should actually be
    // performed.
    assert_eq!(
        Ruleset::from(ABI::V1)
            .set_compatibility(CompatLevel::HardRequirement)
            .handle_access(AccessFs::from_all(ABI::V1))
            .unwrap()
            .set_compatibility(CompatLevel::SoftRequirement)
            // Because Ruleset only supports V1, Refer will be ignored.
            .handle_access(AccessFs::Refer)
            .unwrap()
            .create()
            .unwrap()
            .add_rule(PathBeneath::new(
                PathFd::new("/tmp").unwrap(),
                AccessFs::from_all(ABI::V2)
            ))
            .unwrap()
            .add_rule(PathBeneath::new(
                PathFd::new("/usr").unwrap(),
                make_bitflags!(AccessFs::{ReadFile | ReadDir})
            ))
            .unwrap()
            .restrict_self()
            .unwrap(),
        RestrictionStatus {
            ruleset: RulesetStatus::NotEnforced,
            no_new_privs: true,
        }
    );
}

#[test]
fn unsupported_handled_access() {
    matches!(
        Ruleset::from(ABI::V3)
            .handle_access(AccessNet::from_all(ABI::V3))
            .unwrap_err(),
        RulesetError::HandleAccesses(HandleAccessesError::Net(HandleAccessError::Compat(
            CompatError::Access(AccessError::Empty)
        )))
    );
}
use crate::{Access, AccessFs, AccessNet, BitFlags};
use std::io;
use std::path::PathBuf;
use thiserror::Error;

/// Maps to all errors that can be returned by a ruleset action.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum RulesetError {
    #[error(transparent)]
    HandleAccesses(#[from] HandleAccessesError),
    #[error(transparent)]
    CreateRuleset(#[from] CreateRulesetError),
    #[error(transparent)]
    AddRules(#[from] AddRulesError),
    #[error(transparent)]
    RestrictSelf(#[from] RestrictSelfError),
}

#[test]
fn ruleset_error_breaking_change() {
    use crate::*;

    // Generics are part of the API and modifying them can lead to a breaking change.
    let _: RulesetError = RulesetError::HandleAccesses(HandleAccessesError::Fs(
        HandleAccessError::Compat(CompatError::Access(AccessError::Empty)),
    ));
}

/// Identifies errors when updating the ruleset's handled access-rights.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum HandleAccessError<T>
where
    T: Access,
{
    #[error(transparent)]
    Compat(#[from] CompatError<T>),
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum HandleAccessesError {
    #[error(transparent)]
    Fs(HandleAccessError<AccessFs>),
    #[error(transparent)]
    Net(HandleAccessError<AccessNet>),
}

// Generically implement for all the access implementations rather than for the cases listed in
// HandleAccessesError (with #[from]).
impl<A> From<HandleAccessError<A>> for HandleAccessesError
where
    A: Access,
{
    fn from(error: HandleAccessError<A>) -> Self {
        A::into_handle_accesses_error(error)
    }
}

/// Identifies errors when creating a ruleset.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CreateRulesetError {
    /// The `landlock_create_ruleset()` system call failed.
    #[error("failed to create a ruleset: {source}")]
    #[non_exhaustive]
    CreateRulesetCall { source: io::Error },
    /// Missing call to [`RulesetAttr::handle_access()`](crate::RulesetAttr::handle_access).
    #[error("missing handled access")]
    MissingHandledAccess,
}

/// Identifies errors when adding a rule to a ruleset.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum AddRuleError<T>
where
    T: Access,
{
    /// The `landlock_add_rule()` system call failed.
    #[error("failed to add a rule: {source}")]
    #[non_exhaustive]
    AddRuleCall { source: io::Error },
    /// The rule's access-rights are not all handled by the (requested) ruleset access-rights.
    #[error("access-rights not handled by the ruleset: {incompatible:?}")]
    UnhandledAccess {
        access: BitFlags<T>,
        incompatible: BitFlags<T>,
    },
    #[error(transparent)]
    Compat(#[from] CompatError<T>),
}

// Generically implement for all the access implementations rather than for the cases listed in
// AddRulesError (with #[from]).
impl<A> From<AddRuleError<A>> for AddRulesError
where
    A: Access,
{
    fn from(error: AddRuleError<A>) -> Self {
        A::into_add_rules_error(error)
    }
}

/// Identifies errors when adding rules to a ruleset thanks to an iterator returning
/// Result<Rule, E> items.
#[derive(Debug, Error)]
#[non_exhaustive]
pub enum AddRulesError {
    #[error(transparent)]
    Fs(AddRuleError<AccessFs>),
    #[error(transparent)]
    Net(AddRuleError<AccessNet>),
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum CompatError<T>
where
    T: Access,
{
    #[error(transparent)]
    PathBeneath(#[from] PathBeneathError),
    #[error(transparent)]
    Access(#[from] AccessError<T>),
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum PathBeneathError {
    /// To check that access-rights are consistent with a file descriptor, a call to
    /// [`RulesetCreatedAttr::add_rule()`](crate::RulesetCreatedAttr::add_rule)
    /// looks at the file type with an `fstat()` system call.
    #[error("failed to check file descriptor type: {source}")]
    #[non_exhaustive]
    StatCall { source: io::Error },
    /// This error is returned by
    /// [`RulesetCreatedAttr::add_rule()`](crate::RulesetCreatedAttr::add_rule)
    /// if the related PathBeneath object is not set to best-effort,
    /// and if its allowed access-rights contain directory-only ones
    /// whereas the file descriptor doesn't point to a directory.
    #[error("incompatible directory-only access-rights: {incompatible:?}")]
    DirectoryAccess {
        access: BitFlags<AccessFs>,
        incompatible: BitFlags<AccessFs>,
    },
}

#[derive(Debug, Error)]
// Exhaustive enum
pub enum AccessError<T>
where
    T: Access,
{
    /// The access-rights set is empty, which doesn't make sense and would be rejected by the
    /// kernel.
    #[error("empty access-right")]
    Empty,
    /// The access-rights set was forged with the unsafe `BitFlags::from_bits_unchecked()` and it
    /// contains unknown bits.
    #[error("unknown access-rights (at build time): {unknown:?}")]
    Unknown {
        access: BitFlags<T>,
        unknown: BitFlags<T>,
    },
    /// The best-effort approach was (deliberately) disabled and the requested access-rights are
    /// fully incompatible with the running kernel.
    #[error("fully incompatible access-rights: {access:?}")]
    Incompatible { access: BitFlags<T> },
    /// The best-effort approach was (deliberately) disabled and the requested access-rights are
    /// partially incompatible with the running kernel.
    #[error("partially incompatible access-rights: {incompatible:?}")]
    PartiallyCompatible {
        access: BitFlags<T>,
        incompatible: BitFlags<T>,
    },
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum RestrictSelfError {
    /// The `prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)` system call failed.
    #[error("failed to set no_new_privs: {source}")]
    #[non_exhaustive]
    SetNoNewPrivsCall { source: io::Error },
    /// The `landlock_restrict_self() `system call failed.
    #[error("failed to restrict the calling thread: {source}")]
    #[non_exhaustive]
    RestrictSelfCall { source: io::Error },
}

#[derive(Debug, Error)]
#[non_exhaustive]
pub enum PathFdError {
    /// The `open()` system call failed.
    #[error("failed to open \"{path}\": {source}")]
    #[non_exhaustive]
    OpenCall { source: io::Error, path: PathBuf },
}

#[cfg(test)]
#[derive(Debug, Error)]
pub(crate) enum TestRulesetError {
    #[error(transparent)]
    Ruleset(#[from] RulesetError),
    #[error(transparent)]
    PathFd(#[from] PathFdError),
    #[error(transparent)]
    File(#[from] std::io::Error),
}
use anyhow::{anyhow, Context, Result};
use dialoguer::{Input, Select};
use landlock::{
    Access, AccessFs, AccessNet, ABI, NetPort, PathBeneath, PathFd, Ruleset, RulesetAttr,
    RulesetCreatedAttr,
};
use regex::Regex;
use reqwest::blocking::Client;
use std::collections::HashSet;
use std::env;
use std::fs::{self, File};
use std::io::{BufRead, BufReader};
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};
use tempfile::TempDir;
use supernanny_sandboxer::policy_client::RuleSet;
use supernanny_sandboxer::policy_client::{User, log_denial_event};
use serde::{Deserialize, Serialize};

// ----------------------------------------------------------------------------
// Constants for limiting policy expansion
// ----------------------------------------------------------------------------

const MAX_RO_PATHS: usize = 100;
const MAX_RW_PATHS: usize = 50;
const MAX_TCP_BIND_PORTS: usize = 20;
const MAX_TCP_CONNECT_PORTS: usize = 30;
const MAX_IPS: usize = 50;
const MAX_DOMAINS: usize = 50;

// ----------------------------------------------------------------------------
// AppPolicy
// ----------------------------------------------------------------------------

#[derive(Debug)]
pub struct AppPolicy {
    ro_paths: HashSet<PathBuf>,
    rw_paths: HashSet<PathBuf>,
    tcp_bind: HashSet<u16>,
    tcp_connect: HashSet<u16>,
    allowed_ips: HashSet<String>,
    allowed_domains: HashSet<String>,
}

#[derive(Debug, Deserialize)]
struct RoleCheckResponse {
    permissions: Vec<String>,
}

#[derive(Serialize)]
struct PolicyPayload {
    app_name: String,
    role_id: i32,
    default_ro: String,
    default_rw: String,
    tcp_bind: String,
    tcp_connect: String,
    allowed_ips: String,
    allowed_domains: String,
}

impl From<RuleSet> for AppPolicy {
    fn from(rs: RuleSet) -> Self {
        Self {
            ro_paths: rs.ro_paths,
            rw_paths: rs.rw_paths,
            tcp_bind: rs.tcp_bind,
            tcp_connect: rs.tcp_connect,
            allowed_ips: rs.allowed_ips,
            allowed_domains: rs.allowed_domains,
        }
    }
}

impl AppPolicy {
    fn contains_path(&self, path: &Path) -> bool {
        self.ro_paths.contains(path) || self.rw_paths.contains(path)
    }

    fn join_paths(paths: &HashSet<PathBuf>) -> String {
        paths.iter().map(|p| p.to_string_lossy().into_owned()).collect::<Vec<_>>().join(":")
    }

    fn join_ports(ports: &HashSet<u16>) -> String {
        ports.iter().map(|p| p.to_string()).collect::<Vec<_>>().join(":")
    }

    fn join_ips(ips: &HashSet<String>) -> String {
        ips.iter().cloned().collect::<Vec<_>>().join(":")
    }

    fn join_domains(domains: &HashSet<String>) -> String {
        domains.iter().cloned().collect::<Vec<_>>().join(":")
    }

    // Validate a path is safe to use
    fn validate_path(path: &Path) -> Result<()> {
        // Check path isn't too long
        if path.to_string_lossy().len() > 4096 {
            return Err(anyhow!("Path too long: {}", path.display()));
        }
        
        // Check path doesn't contain unusual characters
        if path.to_string_lossy().contains('\0') {
            return Err(anyhow!("Path contains null bytes: {}", path.display()));
        }
        
        Ok(())
    }
}

// ----------------------------------------------------------------------------
// Auth: just token
// ----------------------------------------------------------------------------

fn get_credentials() -> Result<(String, User)> {
    let username = Input::<String>::new()
        .with_prompt("Username")
        .interact_text()
        .context("Failed to read username")?;
    
    let mut password = dialoguer::Password::new()
        .with_prompt("Password")
        .interact()
        .context("Failed to read password")?;

    // Get the result before clearing password
    let result = RuleSet::login(&username, &password);
    
    // Clear password from memory as soon as possible
    let password_bytes = unsafe { password.as_bytes_mut() };
    for byte in password_bytes {
        *byte = 0;
    }
    drop(password);
    
    result.context("Authentication failed")
}

// ----------------------------------------------------------------------------
// Server communication
// ----------------------------------------------------------------------------

pub fn update_policy_on_server(app: &str, policy: &AppPolicy, token: &str) -> Result<()> {
    let base_url = env::var("SERVER_URL").unwrap_or_else(|_| "http://127.0.0.1:3005".into());
    let client = Client::new();

    //  Step 1: Check if user has "manage_policies"
    let roles_url = format!("{}/auth/roles", base_url);
    let res = client
        .get(&roles_url)
        .bearer_auth(token)
        .send()
        .context("Failed to fetch user permissions")?;

    if !res.status().is_success() {
        return Err(anyhow!("Could not verify user permissions: {}", res.status()));
    }

    let roles_info: RoleCheckResponse = res
        .json()
        .context("Failed to parse roles response")?;

    if !roles_info.permissions.contains(&"manage_policies".to_string()) {
        println!("User does not have 'manage_policies' permission. Skipping policy update.");
        return Ok(());
    }

    // Step 2: Send the policy update
    let update_url = format!("{}/auth/ruleset/update", base_url);

    let payload = PolicyPayload {
        app_name: app.to_string(),
        role_id: 1, // You may keep it static or decode from JWT if needed
        default_ro: AppPolicy::join_paths(&policy.ro_paths),
        default_rw: AppPolicy::join_paths(&policy.rw_paths),
        tcp_bind: AppPolicy::join_ports(&policy.tcp_bind),
        tcp_connect: AppPolicy::join_ports(&policy.tcp_connect),
        allowed_ips: AppPolicy::join_ips(&policy.allowed_ips),
        allowed_domains: AppPolicy::join_domains(&policy.allowed_domains),
    };

    let res = client
        .post(&update_url)
        .bearer_auth(token)
        .json(&payload)
        .send()
        .context("Failed to send policy update")?;

    if !res.status().is_success() {
        return Err(anyhow!("Policy update failed: {}", res.status()));
    }

    println!("Policy update successfully posted to server!");
    Ok(())
}

// ----------------------------------------------------------------------------
// Landlock
// ----------------------------------------------------------------------------

fn enforce_landlock(policy: &AppPolicy) -> Result<()> {
    let abi = ABI::V5;
    let base = Ruleset::default()
        .handle_access(AccessFs::from_all(abi))?
        .handle_access(AccessNet::BindTcp)?
        .handle_access(AccessNet::ConnectTcp)?;
    
    let mut created = base.create().context("Failed to create Landlock ruleset")?;
    
    // Process read-only paths
    for path in &policy.ro_paths {
        if let Err(e) = AppPolicy::validate_path(path) {
            eprintln!("Warning: Skipping invalid read-only path: {}", e);
            continue;
        }
        
        let canonical_path = match fs::canonicalize(path) {
            Ok(p) => p,
            Err(e) => {
                eprintln!("Warning: Failed to canonicalize path {}: {}", path.display(), e);
                continue;
            }
        };
        
        let fd = match PathFd::new(canonical_path.as_os_str()) {
            Ok(fd) => fd,
            Err(e) => {
                eprintln!("Warning: Failed to open path {}: {}", canonical_path.display(), e);
                continue;
            }
        };
        
        let rule = PathBeneath::new(fd, AccessFs::from_read(abi));
        created = created.add_rule(rule)
            .map_err(|e| {
                eprintln!("Warning: Failed to add read-only rule for {}: {}", path.display(), e);
                e
            })?;
    }
    
    // Process read-write paths
    for path in &policy.rw_paths {
        if let Err(e) = AppPolicy::validate_path(path) {
            eprintln!("Warning: Skipping invalid read-write path: {}", e);
            continue;
        }
        
        let canonical_path = match fs::canonicalize(path) {
            Ok(p) => p,
            Err(e) => {
                eprintln!("Warning: Failed to canonicalize path {}: {}", path.display(), e);
                continue;
            }
        };
        
        let fd = match PathFd::new(canonical_path.as_os_str()) {
            Ok(fd) => fd,
            Err(e) => {
                eprintln!("Warning: Failed to open path {}: {}", canonical_path.display(), e);
                continue;
            }
        };
        
        let rule = PathBeneath::new(fd, AccessFs::from_all(abi));
        created = created.add_rule(rule)
            .map_err(|e| {
                eprintln!("Warning: Failed to add read-write rule for {}: {}", path.display(), e);
                e
            })?;
    }
    
    // Process TCP bind ports
    for port in &policy.tcp_bind {
        let rule = NetPort::new(*port, AccessNet::BindTcp);
        created = created.add_rule(rule)
            .map_err(|e| {
                eprintln!("Warning: Failed to add TCP bind rule for port {}: {}", port, e);
                e
            })?;
    }
    
    // Process TCP connect ports
    for port in &policy.tcp_connect {
        let rule = NetPort::new(*port, AccessNet::ConnectTcp);
        created = created.add_rule(rule)
            .map_err(|e| {
                eprintln!("Warning: Failed to add TCP connect rule for port {}: {}", port, e);
                e
            })?;
    }
    
    created.restrict_self()?;
    Ok(())
}


// ----------------------------------------------------------------------------
// Strace
// ----------------------------------------------------------------------------

fn run_strace(app_path: &Path, args: &[String], policy: &AppPolicy, prefix: &str) -> Result<(ExitStatus, TempDir)> {
    // Validate app path
    if let Err(e) = AppPolicy::validate_path(app_path) {
        return Err(anyhow!("Invalid application path: {}", e));
    }

    let tempdir = TempDir::new()?;
    let log_prefix = tempdir.path().join(prefix);
    let log_path = log_prefix.to_string_lossy().to_string();

    let mut envs: Vec<(String, String)> = env::vars().collect();
    envs.push(("LL_FS_RO".into(), AppPolicy::join_paths(&policy.ro_paths)));
    envs.push(("LL_FS_RW".into(), AppPolicy::join_paths(&policy.rw_paths)));
    envs.push(("LL_TCP_BIND".into(), AppPolicy::join_ports(&policy.tcp_bind)));
    envs.push(("LL_TCP_CONNECT".into(), AppPolicy::join_ports(&policy.tcp_connect)));
    envs.push(("LL_ALLOWED_IPS".into(), AppPolicy::join_ips(&policy.allowed_ips)));
    envs.push(("LL_ALLOWED_DOMAINS".into(), AppPolicy::join_domains(&policy.allowed_domains)));

    let current_exe = env::current_exe()?;
    let strace_path = env::var("STRACE_PATH").unwrap_or_else(|_| "/usr/bin/strace".to_string());

    let status = Command::new(strace_path)
        .args(&["-ff", "-yy", "-e", "trace=file,process,openat,getdents,stat,connect,socket,bind"])
        .arg("-o").arg(&log_path)
        .arg(&current_exe)
        .arg("--sandbox")
        .arg(app_path)
        .args(args)
        .env_clear()
        .envs(envs)
        .status()?;

    Ok((status, tempdir))
}

fn parse_denied_lines(dir: &Path, prefix: &str) -> Result<HashSet<String>> {
    let path_re = Regex::new(r#"openat\(.*?,\s*"([^"]+)"|stat\("([^"]+)"|getdents\(.*?,\s*"([^"]+)""#)?;
    let net_re = Regex::new(r#"(connect|bind)\(.*?sin_port=htons\((\d+)\)"#)?;

    let mut denials = HashSet::new();

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        if !entry.file_name().to_string_lossy().starts_with(prefix) {
            continue;
        }

        let file = match File::open(entry.path()) {
            Ok(f) => f,
            Err(e) => {
                eprintln!("Warning: Could not open log file {}: {}", entry.path().display(), e);
                continue;
            }
        };

        for line in BufReader::new(file).lines() {
            let line = match line {
                Ok(l) => l,
                Err(e) => {
                    eprintln!("Warning: Error reading log line: {}", e);
                    continue;
                }
            };
            
            if !(line.contains("EACCES") || line.contains("EPERM")) {
                continue;
            }

            if let Some(cap) = path_re.captures(&line) {
                if let Some(p) = cap.get(1).or_else(|| cap.get(2)).or_else(|| cap.get(3)) {
                    let raw_path = PathBuf::from(p.as_str());
                
                    // Only canonicalize paths if possible, otherwise use the raw path
                    match fs::canonicalize(&raw_path) {
                        Ok(canonical_path) => {
                            denials.insert(canonical_path.to_string_lossy().to_string());
                        },
                        Err(_) => {
                            // If canonicalization fails, use the original path but mark it
                            denials.insert(format!("NONCANONICAL:{}", raw_path.to_string_lossy()));
                        }
                    }
                }
                
            } else if let Some(cap) = net_re.captures(&line) {
                if let (Some(op), Some(port)) = (cap.get(1), cap.get(2)) {
                    // Validate port is a valid number before adding
                    if let Ok(port_num) = port.as_str().parse::<u16>() {
                        denials.insert(format!("tcp:{}:{}", op.as_str(), port_num));
                    } else {
                        eprintln!("Warning: Invalid port number in denial log: {}", port.as_str());
                    }
                }
            }
        }
    }

    Ok(denials)
}

fn process_denials(denials: HashSet<String>, policy: &mut AppPolicy) -> Result<bool> {
    let mut updated = false;

    for entry in denials {
        if entry.starts_with("tcp:") {
            // Existing TCP port handling with original limits
            let parts: Vec<&str> = entry.splitn(3, ':').collect();
            if parts.len() >= 3 {
                let (_, op, port_str) = (parts[0], parts[1], parts[2]);
                
                let port: u16 = match port_str.parse() {
                    Ok(p) => p,
                    Err(e) => {
                        eprintln!("Warning: Invalid TCP port '{}': {}", port_str, e);
                        continue;
                    }
                };
                
                let choices = &["Allow", "Deny"];
                let selection = Select::new()
                    .with_prompt(format!("TCP {} port {} denied. Allow?", op, port))
                    .items(choices)
                    .default(1)
                    .interact()?;

                if selection == 0 {
                    if op == "connect" {
                        if policy.tcp_connect.len() >= MAX_TCP_CONNECT_PORTS {
                            println!("Warning: Maximum TCP connect ports ({}) reached", MAX_TCP_CONNECT_PORTS);
                            continue;
                        }
                        policy.tcp_connect.insert(port);
                        updated = true;
                    } else if op == "bind" {
                        if policy.tcp_bind.len() >= MAX_TCP_BIND_PORTS {
                            println!("Warning: Maximum TCP bind ports ({}) reached", MAX_TCP_BIND_PORTS);
                            continue;
                        }
                        policy.tcp_bind.insert(port);
                        updated = true;
                    }
                }
            }
        } else if entry.starts_with("ip:") {
            // New IP address handling with MAX_IPS
            let ip = entry.strip_prefix("ip:").unwrap_or(&entry);
            
            if policy.allowed_ips.len() >= MAX_IPS {
                println!("Warning: Maximum allowed IPs ({}) reached", MAX_IPS);
                continue;
            }
            
            let choices = &["Allow", "Deny"];
            let selection = Select::new()
                .with_prompt(format!("IP address {} denied. Allow?", ip))
                .items(choices)
                .default(1)
                .interact()?;

            if selection == 0 {
                policy.allowed_ips.insert(ip.to_string());
                updated = true;
            }
        } else if entry.starts_with("domain:") {
            // New domain handling with MAX_DOMAINS
            let domain = entry.strip_prefix("domain:").unwrap_or(&entry);
            
            if policy.allowed_domains.len() >= MAX_DOMAINS {
                println!("Warning: Maximum allowed domains ({}) reached", MAX_DOMAINS);
                continue;
            }
            
            let choices = &["Allow", "Deny"];
            let selection = Select::new()
                .with_prompt(format!("Domain {} denied. Allow?", domain))
                .items(choices)
                .default(1)
                .interact()?;

            if selection == 0 {
                policy.allowed_domains.insert(domain.to_string());
                updated = true;
            }
        }else {
            // Handle non-canonical paths specially
            let is_noncanonical = entry.starts_with("NONCANONICAL:");
            let path_str = if is_noncanonical {
                entry.strip_prefix("NONCANONICAL:").unwrap_or(&entry)
            } else {
                &entry
            };
            
            let path = PathBuf::from(path_str);

            // Validate the path
            if let Err(e) = AppPolicy::validate_path(&path) {
                eprintln!("Warning: Skipping invalid path: {}", e);
                continue;
            }

            // If we couldn't canonicalize earlier, try again now
            let canonical_path = if is_noncanonical {
                match fs::canonicalize(&path) {
                    Ok(p) => p,
                    Err(e) => {
                        eprintln!("Warning: Still unable to canonicalize path {}: {}", path.display(), e);
                        // Skip paths we can't canonicalize for safety
                        continue;
                    }
                }
            } else {
                path.clone()
            };

            if policy.contains_path(&canonical_path) {
                continue;
            }
            
            let choices = &["Read-Only", "Read-Write", "Deny"];
            let selection = Select::new()
                .with_prompt(format!("Denied path: {}. Allow as?", canonical_path.display()))
                .items(choices)
                .default(2)
                .interact()?;
            
            match selection {
                0 => {
                    // Check limits before adding
                    if policy.ro_paths.len() >= MAX_RO_PATHS {
                        println!("Warning: Maximum number of read-only paths ({}) reached.", MAX_RO_PATHS);
                        continue;
                    }
                    policy.ro_paths.insert(canonical_path);
                    updated = true;
                },
                1 => {
                    // Check limits before adding
                    if policy.rw_paths.len() >= MAX_RW_PATHS {
                        println!("Warning: Maximum number of read-write paths ({}) reached.", MAX_RW_PATHS);
                        continue;
                    }
                    policy.rw_paths.insert(canonical_path);
                    updated = true;
                },
                _ => {}
            };
            
        }
    }

    Ok(updated)
}

// ----------------------------------------------------------------------------
// Entrypoint
// ----------------------------------------------------------------------------

fn main() -> Result<()> {
    let args: Vec<String> = env::args().collect();

    // Special --sandbox execution for the strace'd command
    if args.len() >= 2 && args[1] == "--sandbox" {
        return run_sandbox();
    }

    // Authenticate and get token + user object
    let (token, user) = get_credentials().context("Failed to authenticate user")?;
    println!("Authentication successful!");

    // Validate command line usage
    if args.len() < 2 {
        return Err(anyhow!("Usage: {} <APP> [ARGS...]", args[0]));
    }

    let app = &args[1];
    let app_args = &args[2..];

    // Validate app path
    let app_path = Path::new(app);
    if let Err(e) = AppPolicy::validate_path(app_path) {
        return Err(anyhow!("Invalid application path: {}", e));
    }

    // Retrieve policy from server
    let ruleset = RuleSet::fetch_for_app(app, &token)
        .context("Failed to fetch policy from server")?;
    let mut policy = AppPolicy::from(ruleset);

    // First run
    let (status, tempdir) = run_strace(app_path, app_args, &policy, "sandbox_log")?;
    let denials = parse_denied_lines(tempdir.path(), "sandbox_log")?;

    // Log denials if any
    if !denials.is_empty() {
        for denial in &denials {
            let resource_type = if denial.starts_with("tcp:") {
                "network"
            } else {
                "filesystem"
            };

            let _ = log_denial_event(app, denial, resource_type, &token);
        }
    }

    // Check if rerun is needed
    if !status.success() || !denials.is_empty() {
        if user.has_permission("manage_policies") {
            let updated = process_denials(denials.clone(), &mut policy)?;
            if updated {
                update_policy_on_server(app, &policy, &token)
                    .context("Failed to upload updated policy")?;
        
                let rerun = dialoguer::Confirm::new()
                    .with_prompt("Rerun with updated policy?")
                    .default(true)
                    .interact()
                    .unwrap_or(false);
        
                if rerun {
                    let (_rerun_status, _rerun_temp) = run_strace(app_path, app_args, &policy, "rerun_log")?;
                    println!("Second run completed.");
                }
            } else {
                println!("No changes to apply.");
            }
        }        
        else {
            println!("Access denied events have been logged. Contact an admin if access is needed.");
            for denial in &denials {
                println!("  - Denied: {}", denial);
            }
        }
    } else {
        println!("App ran successfully with current policy.");
    }

    Ok(())
}


fn run_sandbox() -> Result<()> {
    let args: Vec<String> = env::args().collect();
    if args.len() < 3 {
        return Err(anyhow!("Usage: {} --sandbox <APP> [ARGS...]", args[0]));
    }

    let cmd = &args[2];
    let cmd_args = &args[3..];
    
    // Validate command path
    let cmd_path = Path::new(cmd);
    if let Err(e) = AppPolicy::validate_path(cmd_path) {
        return Err(anyhow!("Invalid command path: {}", e));
    }
    
    let policy = AppPolicy {
        ro_paths: env::var("LL_FS_RO").unwrap_or_default().split(':').filter(|s| !s.is_empty()).map(PathBuf::from).collect(),
        rw_paths: env::var("LL_FS_RW").unwrap_or_default().split(':').filter(|s| !s.is_empty()).map(PathBuf::from).collect(),
        tcp_bind: env::var("LL_TCP_BIND").unwrap_or_default().split(':').filter_map(|s| s.parse().ok()).collect(),
        tcp_connect: env::var("LL_TCP_CONNECT").unwrap_or_default().split(':').filter_map(|s| s.parse().ok()).collect(),
        allowed_ips: env::var("LL_ALLOWED_IPS").unwrap_or_default().split(':').filter(|s| !s.is_empty()).map(String::from).collect(),
        allowed_domains: env::var("LL_ALLOWED_DOMAINS").unwrap_or_default().split(':').filter(|s| !s.is_empty()).map(String::from).collect(),
    };

    // Get token for event logging but remove it from environment
    let token = env::var("LL_AUTH_TOKEN").ok();
    // Remove sensitive env vars so they aren't passed to the sandboxed application
    std::env::remove_var("LL_AUTH_TOKEN");
    
    // Apply Landlock restrictions - fail closed for security
    if let Err(e) = enforce_landlock(&policy) {
        eprintln!("Error: Failed to apply Landlock restrictions: {}", e);
        // Try to log the error if we have a token
        if let Some(token) = &token {
            let _ = log_denial_event(cmd, &format!("landlock_setup_error:{}", e), "system", token);
        }
        // Fail closed for security
        return Err(anyhow!("Cannot run without sandbox protection: {}", e));
    }
    
    // Execute the sandboxed command
    let status = Command::new(cmd).args(cmd_args).status()?;
    
    // If command failed and we have a token, try to log a general failure
    if !status.success() && token.is_some() {
        let _ = log_denial_event(cmd, &format!("exit_status:{}", status), "application", &token.unwrap());
    }
    
    std::process::exit(status.code().unwrap_or(1));
}use crate::{
    AccessError, AddRuleError, AddRulesError, BitFlags, CompatError, CompatResult,
    HandleAccessError, HandleAccessesError, Ruleset, TailoredCompatLevel, TryCompat, ABI,
};
use enumflags2::BitFlag;

#[cfg(test)]
use crate::{make_bitflags, AccessFs, CompatLevel, CompatState, Compatibility};

pub trait Access: PrivateAccess {
    /// Gets the access rights defined by a specific [`ABI`].
    fn from_all(abi: ABI) -> BitFlags<Self>;
}

pub trait PrivateAccess: BitFlag {
    fn ruleset_handle_access(
        ruleset: &mut Ruleset,
        access: BitFlags<Self>,
    ) -> Result<(), HandleAccessesError>
    where
        Self: Access;

    fn into_add_rules_error(error: AddRuleError<Self>) -> AddRulesError
    where
        Self: Access;

    fn into_handle_accesses_error(error: HandleAccessError<Self>) -> HandleAccessesError
    where
        Self: Access;
}

// Creates an illegal/overflowed BitFlags<T> with all its bits toggled, including undefined ones.
fn full_negation<T>(flags: BitFlags<T>) -> BitFlags<T>
where
    T: Access,
{
    unsafe { BitFlags::<T>::from_bits_unchecked(!flags.bits()) }
}

#[test]
fn bit_flags_full_negation() {
    let scoped_negation = !BitFlags::<AccessFs>::all();
    assert_eq!(scoped_negation, BitFlags::<AccessFs>::empty());
    // !BitFlags::<AccessFs>::all() could be equal to full_negation(BitFlags::<AccessFs>::all()))
    // if all the 64-bits would be used, which is not currently the case.
    assert_ne!(scoped_negation, full_negation(BitFlags::<AccessFs>::all()));
}

impl<A> TailoredCompatLevel for BitFlags<A> where A: Access {}

impl<A> TryCompat<A> for BitFlags<A>
where
    A: Access,
{
    fn try_compat_inner(&mut self, abi: ABI) -> Result<CompatResult<A>, CompatError<A>> {
        if self.is_empty() {
            // Empty access-rights would result to a runtime error.
            Err(AccessError::Empty.into())
        } else if !Self::all().contains(*self) {
            // Unknown access-rights (at build time) would result to a runtime error.
            // This can only be reached by using the unsafe BitFlags::from_bits_unchecked().
            Err(AccessError::Unknown {
                access: *self,
                unknown: *self & full_negation(Self::all()),
            }
            .into())
        } else {
            let compat = *self & A::from_all(abi);
            let ret = if compat.is_empty() {
                Ok(CompatResult::No(
                    AccessError::Incompatible { access: *self }.into(),
                ))
            } else if compat != *self {
                let error = AccessError::PartiallyCompatible {
                    access: *self,
                    incompatible: *self & full_negation(compat),
                }
                .into();
                Ok(CompatResult::Partial(error))
            } else {
                Ok(CompatResult::Full)
            };
            *self = compat;
            ret
        }
    }
}

#[test]
fn compat_bit_flags() {
    use crate::ABI;

    let mut compat: Compatibility = ABI::V1.into();
    assert!(compat.state == CompatState::Init);

    let ro_access = make_bitflags!(AccessFs::{Execute | ReadFile | ReadDir});
    assert_eq!(
        ro_access,
        ro_access
            .try_compat(compat.abi(), compat.level, &mut compat.state)
            .unwrap()
            .unwrap()
    );
    assert!(compat.state == CompatState::Full);

    let empty_access = BitFlags::<AccessFs>::empty();
    assert!(matches!(
        empty_access
            .try_compat(compat.abi(), compat.level, &mut compat.state)
            .unwrap_err(),
        CompatError::Access(AccessError::Empty)
    ));

    let all_unknown_access = unsafe { BitFlags::<AccessFs>::from_bits_unchecked(1 << 63) };
    assert!(matches!(
        all_unknown_access.try_compat(compat.abi(), compat.level, &mut compat.state).unwrap_err(),
        CompatError::Access(AccessError::Unknown { access, unknown }) if access == all_unknown_access && unknown == all_unknown_access
    ));
    // An error makes the state final.
    assert!(compat.state == CompatState::Dummy);

    let some_unknown_access = unsafe { BitFlags::<AccessFs>::from_bits_unchecked(1 << 63 | 1) };
    assert!(matches!(
        some_unknown_access.try_compat(compat.abi(), compat.level, &mut compat.state).unwrap_err(),
        CompatError::Access(AccessError::Unknown { access, unknown }) if access == some_unknown_access && unknown == all_unknown_access
    ));
    assert!(compat.state == CompatState::Dummy);

    compat = ABI::Unsupported.into();

    // Tests that the ruleset is marked as unsupported.
    assert!(compat.state == CompatState::Init);

    // Access-rights are valid (but ignored) when they are not required for the current ABI.
    assert_eq!(
        None,
        ro_access
            .try_compat(compat.abi(), compat.level, &mut compat.state)
            .unwrap()
    );

    assert!(compat.state == CompatState::No);

    // Access-rights are not valid when they are required for the current ABI.
    compat.level = Some(CompatLevel::HardRequirement);
    assert!(matches!(
        ro_access.try_compat(compat.abi(), compat.level, &mut compat.state).unwrap_err(),
        CompatError::Access(AccessError::Incompatible { access }) if access == ro_access
    ));

    compat = ABI::V1.into();

    // Tests that the ruleset is marked as the unknown compatibility state.
    assert!(compat.state == CompatState::Init);

    // Access-rights are valid (but ignored) when they are not required for the current ABI.
    assert_eq!(
        ro_access,
        ro_access
            .try_compat(compat.abi(), compat.level, &mut compat.state)
            .unwrap()
            .unwrap()
    );

    // Tests that the ruleset is in an unsupported state, which is important to be able to still
    // enforce no_new_privs.
    assert!(compat.state == CompatState::Full);

    let v2_access = ro_access | AccessFs::Refer;

    // Access-rights are not valid when they are required for the current ABI.
    compat.level = Some(CompatLevel::HardRequirement);
    assert!(matches!(
        v2_access.try_compat(compat.abi(), compat.level, &mut compat.state).unwrap_err(),
        CompatError::Access(AccessError::PartiallyCompatible { access, incompatible })
            if access == v2_access && incompatible == AccessFs::Refer
    ));
}
use anyhow::{Context, Result};
use reqwest::blocking::Client;
use serde::Serialize;
use std::{env, path::Path};

#[derive(Debug, Serialize)]
pub struct SandboxLogEntry {
    pub app_name: String,
    pub denied_path: String,
    pub operation: String,
    pub result: String,
}

pub fn log_event(
    jwt: &str,
    user_id: i32,
    app_name: &str,
    path: &Path,
    operation: &str,
    result: &str,
) -> Result<()> {
    let log = SandboxLogEntry {
        app_name: app_name.into(),
        denied_path: path.to_string_lossy().into_owned(),
        operation: operation.into(),
        result: result.into(),
    };

    let base_url = env::var("SERVER_URL").unwrap_or_else(|_| "http://127.0.0.1:3005".into());

    let client = Client::new();
    let response = client
        .post(&format!("{}/events/log", base_url))
        .bearer_auth(jwt)
        .json(&log)
        .send()
        .context("Failed to send log to server")?;

    if !response.status().is_success() {
        return Err(anyhow::anyhow!("Failed to log event: {}", response.status()));
    }

    Ok(())
}
